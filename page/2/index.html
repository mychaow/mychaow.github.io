<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="我住8楼">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="我住8楼">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason Chao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>我住8楼</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我住8楼</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason Chao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/11/SQLite%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/11/SQLite%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">SQLite事务管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-11 20:46:49" itemprop="dateCreated datePublished" datetime="2021-07-11T20:46:49+08:00">2021-07-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-29 23:14:10" itemprop="dateModified" datetime="2021-07-29T23:14:10+08:00">2021-07-29</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="事务类型"><a href="#事务类型" class="headerlink" title="事务类型"></a>事务类型</h1><h2 id="系统事务"><a href="#系统事务" class="headerlink" title="系统事务"></a>系统事务</h2><h3 id="系统事务-1"><a href="#系统事务-1" class="headerlink" title="系统事务"></a>系统事务</h3><p>每条语句都会被包装成一个事务的形式进行执行。一个应用可以在一个数据库链接中并发执行多个查询事务，但是只能执行一个写入事务。</p>
<h3 id="用户事务"><a href="#用户事务" class="headerlink" title="用户事务"></a>用户事务</h3><p>默认系统事务时自动提交模式，即针对每条语句都会有事务包装起来执行。对于写入比较频繁的应用来说性能非常不友好。因为一次写事务提交都涉及到重新打开、写入和关闭日志文件的操作。并且，这还有并发控制的开销，因为应用需要为每个语句执行重新获取和释放锁。</p>
<p>通过将多条语句组合成一个用户事务，可以降低这些性能开销。</p>
<h3 id="子事务"><a href="#子事务" class="headerlink" title="子事务"></a>子事务</h3><p>在一个用户事务中，连续的非查询操作可以作为一个子事务执行。而查询操作则是单独的子事务操作。如果一个用户事务里有几个联系非查询操作，它们会作为一个子事务来执行。如果其中某个执行失败了，数据库会恢复到这个操作之前的状态，然后接着执行下一个操作。</p>
<p>当前有五种处理违反约束的更新后的回滚策略：</p>
<ol>
<li>回滚，中止当前子事务</li>
<li>中止当前语句，但是当前子事务的其他语句还是继续执行，这个也是默认策略</li>
<li>失败，接受当前语句执行失败后的改动，并停止当前语句更进一步的改动。整个子事务继续执行。</li>
<li>忽略，当前语句更新的有问题的行的更新被忽略，整个子事务继续执行。</li>
<li>替代，违反约束的行直接被移除，子事务继续执行。</li>
</ol>
<h2 id="锁管理"><a href="#锁管理" class="headerlink" title="锁管理"></a>锁管理</h2><p>目前只有数据库级别的锁。</p>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ol>
<li>NOLOCK<ol>
<li>事务初始状态就是无锁的，不能读写数据库</li>
</ol>
</li>
<li>SHARED<ol>
<li>允许读。任意数量的事务都可以获得共享锁。只有当所有的共享锁被释放了，才能执行写操作。</li>
</ol>
</li>
<li>EXCLUSIVE<ol>
<li>写锁。一个数据库只有一个写锁。如果存在写锁，其他的锁都不能存在。</li>
</ol>
</li>
<li>RESERVED<ol>
<li>预留锁。这个事务过会儿要执行写，不过当前只是读。其他的事务还是可以继续加shared锁。</li>
</ol>
</li>
<li>PENGDING<ol>
<li>阻塞锁。这个事务马上要执行写，此时就是在等所有的shared锁被释放，然后转成exclusive锁。其他的事务不能再加锁了。</li>
</ol>
</li>
</ol>
<p><img src="C:/Users/94121/AppData/Local/Temp/企业微信截图_1627450277474.png" alt="img"></p>
<h3 id="锁获取顺序"><a href="#锁获取顺序" class="headerlink" title="锁获取顺序"></a>锁获取顺序</h3><p><img src="C:/Users/94121/AppData/Local/Temp/企业微信截图_16274509232827.png" alt="img"></p>
<p>正常获取锁的顺序是上图黑色粗线的顺序。</p>
<p>从Shared到Pending，只有一种情况会发生：当一个事务在读时，需要进行日志回滚。</p>
<p>这些锁对用户不会暴露，全都是lockmanager自己进行锁获取和释放。</p>
<h3 id="死锁和饥饿"><a href="#死锁和饥饿" class="headerlink" title="死锁和饥饿"></a>死锁和饥饿</h3><p>当两个事务同时获得shared锁，然后都要去获取Reserved锁时，其中一个成功，但是他要等待别的事务释放shared 锁才能变成exclusive锁。此时就产生死锁。解决办法就是在事务内多次尝试获得锁，如果超过指定次数锁还未获得，就释放掉自己的锁。</p>
<p>但是这样还会有一个饥饿的问题，就是多个事务一直并发获得锁，然后都尝试多次失败，再回滚事务，导致一直没法进行下去。也可以称为活锁。</p>
<h3 id="锁实现"><a href="#锁实现" class="headerlink" title="锁实现"></a>锁实现</h3><p>如下图所示，sqlite使用不同区域来加不同的锁的方式实现四种锁。</p>
<p>linux只支持两种文件锁：读锁和写锁。写锁是排他的。但是锁可以锁定文件的某段区域，因此一个文件可能会同时存在多把锁，只要它们区域不一样。</p>
<p>sqlite锁的实现方式如下：</p>
<ol>
<li>shared锁，通过在指定区域加读锁来实现</li>
<li>exclusive锁，通过给指定区域的所有字节加上写锁。</li>
<li>reserved锁，通过在某个指定的字节里加上写锁来实现的。</li>
<li>pending锁，也在另一个指定的字节里加上写锁来实现的。</li>
</ol>
<p>如下图所示：</p>
<p>锁页的起始位置定义在PENDING_BYTE里。第一个字节是pending锁字节，第二个字节是reserve锁字节。第三个开始接下来510个字节是shared锁字节。</p>
<p><img src="C:/Users/94121/AppData/Local/Temp/企业微信截图_1627484504367.png" alt="img"></p>
<h4 id="sqlite锁映射成文件锁"><a href="#sqlite锁映射成文件锁" class="headerlink" title="sqlite锁映射成文件锁"></a>sqlite锁映射成文件锁</h4><ol>
<li>一个进程如果要获得shared锁，先获取pending byte的读锁（这个主要是为了确保没有别的进程获取到pending锁了），如果获取成功，说明从shared first开始的都是读锁。这个pending的读锁最终会被释放掉。</li>
<li>一个进程只有在获得shared锁之后才能获得reserved锁，在reserved byte加上写锁即可。但是它本身的shared锁不会被释放，这个为了防止别的进程也获得exclude锁。（这个是为何？不加shared锁，就有可能别的进程也能获得exclusive锁？）</li>
<li>一个进程只有在获得shared锁之后才能获得pending锁，在pending byte加上写锁即可。但是它本身的shared锁不会被释放，这个为了防止别的进程也获得reserved锁。（这个是为何？不加shared锁，就有可能别的进程也能获得exclusive锁？因为获取exclusive锁需要其他进程的shared锁都释放掉，假设有没有释放的就不能加上exclusive锁）</li>
<li>一个进程只有在获得pending锁之后才能获得exclusive锁。为了获得exclusive锁，需要在所有的shared byte上加上写锁即可。</li>
</ol>
<p><img src="C:/Users/94121/AppData/Local/Temp/企业微信截图_16274868398561.png" alt="img"></p>
<h4 id="工程问题"><a href="#工程问题" class="headerlink" title="工程问题"></a>工程问题</h4><ol>
<li>锁映射问题，一个进程只能获得一个文件的一把锁，如果多线程，那就sqlite自己模拟出多个锁对象unixFile，但是共享一个unixInodeInfo对象，这个对象才是这个进程对文件的linux锁。</li>
</ol>
<p><img src="C:/Users/94121/AppData/Local/Temp/企业微信截图_16274878971206.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/" class="post-title-link" itemprop="url">sqlite文件探索</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-06 22:18:12" itemprop="dateCreated datePublished" datetime="2021-07-06T22:18:12+08:00">2021-07-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-11 20:45:56" itemprop="dateModified" datetime="2021-07-11T20:45:56+08:00">2021-07-11</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="存储组织"><a href="#存储组织" class="headerlink" title="存储组织"></a>存储组织</h1><h2 id="数据命名规则"><a href="#数据命名规则" class="headerlink" title="数据命名规则"></a>数据命名规则</h2><p>应用程序通过向sqlite3_open传入数据库文件名来打开数据库。文件名可以是相对路径也可以是绝对路径。SQLite支持常见的文件系统支持的文件名，但是有两条例外：</p>
<ul>
<li><p> 如果文件名是c语言NULL指针（例如：0）或者空字符串，或者只包含空字符的字符串，SQLite打开一个新的临时文件</p>
</li>
<li><p>如果文件名是”:memory:”，SQLite创建一个只在内存中存在的数据库(in-memory database)</p>
</li>
</ul>
<p>在这两种情况下创建的数据库文件是临时的，只要数据库关闭，文件就会消失。</p>
<blockquote>
<p>临时文件的作用：回滚日志、语句日志、多数据库主机日志、临时索引、vacuum命令使用的临时数据库、物化视图以及子查询</p>
</blockquote>
<p>在SQLite内部，数据库文件的名字不是数据库名。他们是两个不同的概念。通过使用attach命令，你可以将一个同样的数据库文件以一个不同的数据库名称连接到一个数据库连接上。你可以通过这些数据库名称对数据库文件进行操作。更多有关attach的信息请查询官网。</p>
<p>如下图所示：每当应用程序使用sqlite3_open打开一个数据库连接，SQLite就为这个数据库连接维护一个独立的临时数据库，这个临时数据库被命名为temp。temp数据库存储临时实体，例如：表和索引。（应用程序可以在SQL语句中使用main或者temp，例如：select * from temp.table1将返回temp数据库的table1的所有行，而不是从main数据库返回这些信息。Temp数据库的目录名是sqlite_temp_master）临时实体只对本数据库连接是可见的（而不是指向同一个文件的，同一个线程、进程或者其他进程中的数据库连接）。SQLite将temp数据库存储在一个单独的临时文件中，而不是存储在main数据库文件中。当应用程序关闭数据库连接的时候，temp文件将被删除。</p>
<p><em>临时数据库用来干什么的呢？为什么关闭后要删除？只是为了方便用户操作一些临时信息，而不用再attach一个临时数据库</em></p>
<img src="/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16255823128073.png" class="" title="img">

<h2 id="数据库文件格式"><a href="#数据库文件格式" class="headerlink" title="数据库文件格式"></a>数据库文件格式</h2><p>如下图所示：数据库文件划分为多个固定大小的页</p>
<img src="/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16256677282275.png" class="" title="img">

<p>默认页大小是1024B，可以在编译的时候指定默认值。大小范围是512~65536，不过页的大小必须得是2的幂次方。也可以在创建表之前通过一个参数page_size来制定页大小。</p>
<h3 id="页类型"><a href="#页类型" class="headerlink" title="页类型"></a>页类型</h3><ul>
<li>free：未使用的页</li>
<li>tree<ul>
<li>leaf, B+树的叶子节点会存放数据，如果一个页存放不下，剩下部分会存到溢出页中</li>
<li>internal，B+树的内部节点存放的是下一层节点的索引，B树则是索引和数据都会存放，B树一般用来做索引，B+树则是存数据</li>
<li>overflow</li>
</ul>
</li>
<li>pointer-map：</li>
<li>lock-byte</li>
</ul>
<h3 id="Page-1"><a href="#Page-1" class="headerlink" title="Page 1"></a>Page 1</h3><p>page 1是特殊的，一般用来存放B树根节点，以及前100字节的数据库相关属性信息</p>
<img src="/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16256683475039.png" class="" title="img">

<p>下面是header的内容，页被分成多个cell。</p>
<p>其中22-24字节的意思：</p>
<ol>
<li>最大碎片负载（偏移量是21）指的是每页能够用于存储B/B+树内部节点的空间。255表示100%。默认值是64（25%），这个值用来限定cell的最大值，即每个节点最少有4个cell。如果cell的大小超过允许的最大值，SQLite就创建溢出页，把尽量多的byte移动到溢出页中，但是不能在分割的过程中导致cell的大小小于最小embedded payload(偏移量是22，默认值是32，即12.5%)。</li>
<li>叶子页最小负载（偏移量23）和最小embedded payload相似，但是是针对B+树的叶子页来说的。（默认值是32,12.5%）。叶子页的最大负载百分比永远是100%，文件头中并没有保存该值的变量。</li>
</ol>
<img src="/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16256691984879.png" class="" title="img">



<h3 id="Incremental-Vacuum-amp-Autovacuum"><a href="#Incremental-Vacuum-amp-Autovacuum" class="headerlink" title="Incremental Vacuum &amp; Autovacuum"></a><strong>Incremental Vacuum &amp; Autovacuum</strong></h3><p>vacuum命令可以清空自由页链表。该命令在内存中建立一个数据库的副本（这个副本是通过INSERT INTO…SELECT * FROM…命令实现的）。然后在事务系统的保护下，用内存中的副本重写原始数据库。</p>
<h3 id="free-list"><a href="#free-list" class="headerlink" title="free list"></a>free list</h3><p>自由页链表（偏移量32）存储未使用的页。自由页页数存储在偏移量36。在自由页链表中页有两种类型：主干页和叶子页。文件头指出了自由页链表中的第一个主干页。每一个主干页里含有指向许多叶子页的指针。</p>
<img src="/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16256704019401.png" class="" title="img">

<p>主干页的格式如下所示：</p>
<ul>
<li><p>下一个主干页的页号（4bytes）</p>
</li>
<li><p>本页中含有的叶子页指针个数（4bytes）</p>
</li>
<li><p>0或者更多4bytes叶子页页号</p>
</li>
</ul>
<p>当一个页变为非激活态，SQLite将该页添加到自由页链表中，并不会把页释放给本地文件系统。当你向数据库中添加新的数据的时候，SQLite从自由页链表中取出一页用来存储用户添加的数据。如果自由页链表是空的，SQLite向本地文件系统申请新的页，把新页附加到数据库文件上。</p>
<h2 id="日志文件格式"><a href="#日志文件格式" class="headerlink" title="日志文件格式"></a>日志文件格式</h2><p>SQLite最新的支持wal日志，后面会介绍。下面是一些旧的日志格式设计。</p>
<h3 id="回滚日志"><a href="#回滚日志" class="headerlink" title="回滚日志"></a>回滚日志</h3><p>回滚日志跟数据库文件在同一个目录下，每次写事务开始时创建，事务完成后就被删除。它的名字是数据库名字-journal。</p>
<h4 id="日志整体结构"><a href="#日志整体结构" class="headerlink" title="日志整体结构"></a>日志整体结构</h4><p>如下图所示，是回滚日志的结构。日志会被分成多个日志段，每个日志段会有一个头部。</p>
<img src="/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16257554339707.png" class="" title="img">

<h4 id="日志段header结构"><a href="#日志段header结构" class="headerlink" title="日志段header结构"></a>日志段header结构</h4><img src="/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16257553541447.png" class="" title="img">

<p>下面是各个字段的解释。</p>
<blockquote>
<p> 其中需要说明的是第16字节开始的4个字节，表示的是当前日志文件创建时数据库中含有的页个数。</p>
</blockquote>
<img src="/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16257556265152.png" class="" title="img">

<h4 id="日志记录结构"><a href="#日志记录结构" class="headerlink" title="日志记录结构"></a>日志记录结构</h4><img src="/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/image-20210710224302053.png" class="" title="image-20210710224302053">

<p>需要说明的是校验和的位置的安排是为了简单快速的检测到大概率出现的日志损坏问题。</p>
<ol>
<li>因为如果一条日志损坏，大概率是因为掉电导致的。而写入一般都是线性写入，因此只会出现一条日志的末尾或者中间是有问题，而不会出现两端没有问题，只有中间出问题的情况。<ol>
<li>这里意思是checksum如果放在前面，那page number和checksum可能是对的，但是后面的data page image则可能发生了变化。但是最后校验的时候不就知道有问题了么？</li>
<li><strong>可能data page image没写成功，但是checksum还是跟原来一样。但是如果把checksum放到最后，如果data page image没有写成功，checksum肯定也没写成功，那不可能出现成功的校验？</strong></li>
</ol>
</li>
<li>另外，检验和校验的东西包括page number和中间的数据，还把日志段的头部那个随机数作为key，这样能尽量防止垃圾数据被认为是有效数据的概率。因为垃圾数据一般是旧的未删除的日志文件里的，每次新的日志段都会产生新的随机数，因此加上这个，能降低检验和一致，但是数据其实不一致的问题。</li>
</ol>
<h3 id="语句声明日志"><a href="#语句声明日志" class="headerlink" title="语句声明日志"></a>语句声明日志</h3><p>用来支持语句中止功能的。当有语句执行出错时，就需要语句声明日志来把数据恢复到正常的状态。它实际上是一个临时的回滚日志。</p>
<h3 id="多数据库事务日志"><a href="#多数据库事务日志" class="headerlink" title="多数据库事务日志"></a>多数据库事务日志</h3><p>跨数据库事务时，因为每个数据库都有自己的回滚日志，因此跨数据库事务非原子的。为了做到原子，就支持一种多数据库事务日志，这种日志只包含子事务的回滚日志文件路径。跨数据库事务文件只有在要提交事务时才创建，如果事务中止，不会创建。</p>
<p>如下图所示，每个子事务日志也包含一条跨数据库事务文件的路径记录。这个记录是在事务提交的时候append进去的。</p>
<img src="/2021/07/06/sqlite%E6%96%87%E4%BB%B6%E6%8E%A2%E7%B4%A2/image-20210711145809505.png" class="" title="image-20210711145809505">

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>SQLite的数据都存放在一个文件中，一个数据库文件可以理解为页的数组，可以伸缩。页被分为四类：空闲、树、锁字节、指针map。其中树页又可以细分为三类：中间页，叶子页，溢出页。所有的页中第一页是比较特殊的，它作为所有其他的页的根。</li>
<li>SQLite支持三种过时的日志类型：回滚，语句声明，多数据库事务。回滚日志存放多个日志段，每个日志段由一个日志段头和多条日志记录组成。日志记录则由页个数，旧页数据，校验和组成。语句声明日志则记录单个插入、更新、删除操作的执行影响的回滚日志。跨数据库事务日志存放的是所有参与单个事务的子回滚日志的路径。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.sqlite.org/fileformat.html">Database File Format (sqlite.org)</a></li>
<li>SQLite Database System Design and Implementation</li>
<li>inside sqlite</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/05/sqlite%E8%99%9A%E6%8B%9F%E6%9C%BAvdbe%E5%88%9D%E8%A7%88-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/05/sqlite%E8%99%9A%E6%8B%9F%E6%9C%BAvdbe%E5%88%9D%E8%A7%88-01/" class="post-title-link" itemprop="url">sqlite虚拟机vdbe初览-01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-05 22:28:35 / 修改时间：22:40:35" itemprop="dateCreated datePublished" datetime="2021-07-05T22:28:35+08:00">2021-07-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Sqlite虚拟机"><a href="#Sqlite虚拟机" class="headerlink" title="Sqlite虚拟机"></a>Sqlite虚拟机</h1><p>数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct VdbeOp &#123;</span><br><span class="line">  u8 opcode;          &#x2F;* What operation to perform *&#x2F;</span><br><span class="line">  signed char p4type; &#x2F;* One of the P4_xxx constants for p4 *&#x2F;</span><br><span class="line">  u16 p5;             &#x2F;* Fifth parameter is an unsigned 16-bit integer *&#x2F;</span><br><span class="line">  int p1;             &#x2F;* First operand *&#x2F;</span><br><span class="line">  int p2;             &#x2F;* Second parameter (often the jump destination) *&#x2F;</span><br><span class="line">  int p3;             &#x2F;* The third parameter *&#x2F;</span><br><span class="line">  union p4union &#123;     &#x2F;* fourth parameter *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct VdbeSorter &#123;</span><br><span class="line">  int mnPmaSize;                  &#x2F;* Minimum PMA size, in bytes *&#x2F;</span><br><span class="line">  int mxPmaSize;                  &#x2F;* Maximum PMA size, in bytes.  0&#x3D;&#x3D;no limit *&#x2F;</span><br><span class="line">  int mxKeysize;                  &#x2F;* Largest serialized key seen so far *&#x2F;</span><br><span class="line">  int pgsz;                       &#x2F;* Main database page size *&#x2F;</span><br><span class="line">  PmaReader *pReader;             &#x2F;* Readr data from here after Rewind() *&#x2F;</span><br><span class="line">  MergeEngine *pMerger;           &#x2F;* Or here, if bUseThreads&#x3D;&#x3D;0 *&#x2F;</span><br><span class="line">  sqlite3 *db;                    &#x2F;* Database connection *&#x2F;</span><br><span class="line">  KeyInfo *pKeyInfo;              &#x2F;* How to compare records *&#x2F;</span><br><span class="line">  UnpackedRecord *pUnpacked;      &#x2F;* Used by VdbeSorterCompare() *&#x2F;</span><br><span class="line">  SorterList list;                &#x2F;* List of in-memory records *&#x2F;</span><br><span class="line">  int iMemory;                    &#x2F;* Offset of free space in list.aMemory *&#x2F;</span><br><span class="line">  int nMemory;                    &#x2F;* Size of list.aMemory allocation in bytes *&#x2F;</span><br><span class="line">  u8 bUsePMA;                     &#x2F;* True if one or more PMAs created *&#x2F;</span><br><span class="line">  u8 bUseThreads;                 &#x2F;* True to use background threads *&#x2F;</span><br><span class="line">  u8 iPrev;                       &#x2F;* Previous thread used to flush PMA *&#x2F;</span><br><span class="line">  u8 nTask;                       &#x2F;* Size of aTask[] array *&#x2F;</span><br><span class="line">  u8 typeMask;</span><br><span class="line">  SortSubtask aTask[1];           &#x2F;* One or more subtasks *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/" class="post-title-link" itemprop="url">vscode+wsl 调试sqlite</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-25 16:56:05 / 修改时间：23:06:22" itemprop="dateCreated datePublished" datetime="2021-06-25T16:56:05+08:00">2021-06-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><blockquote>
<p>环境要求：</p>
<ol>
<li>win10 1943 +</li>
<li>x86</li>
</ol>
</blockquote>
<h2 id="wsl-升级为wsl2"><a href="#wsl-升级为wsl2" class="headerlink" title="wsl 升级为wsl2"></a>wsl 升级为wsl2</h2><h3 id="开启linux子系统功能"><a href="#开启linux子系统功能" class="headerlink" title="开启linux子系统功能"></a>开启linux子系统功能</h3><p>以管理员身份打开powershell，在终端里执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe &#x2F;online &#x2F;enable-feature &#x2F;featurename:Microsoft-Windows-Subsystem-Linux &#x2F;all &#x2F;norestart</span><br></pre></td></tr></table></figure>
<h3 id="开启虚拟机功能"><a href="#开启虚拟机功能" class="headerlink" title="开启虚拟机功能"></a>开启虚拟机功能</h3><p>WSL2需要使用虚拟机，因此需要在系统中启动虚拟机功能。</p>
<p>打开PowerShell，执行命令 ：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>
<p>然后重启系统</p>
<h3 id="下载linux子系统内核更新包并进行安装"><a href="#下载linux子系统内核更新包并进行安装" class="headerlink" title="下载linux子系统内核更新包并进行安装"></a>下载linux子系统内核更新包并进行安装</h3><p>链接如下<a target="_blank" rel="noopener" href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a></p>
<h3 id="设置WSL为版本2"><a href="#设置WSL为版本2" class="headerlink" title="设置WSL为版本2"></a>设置WSL为版本2</h3><p>打开PowerShell，执行命令 ：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>
<h2 id="安装ubuntu20-04"><a href="#安装ubuntu20-04" class="headerlink" title="安装ubuntu20.04"></a>安装ubuntu20.04</h2><p>在Microsoft Store中搜索ubuntu，然后点击下面红框的第一个，点击安装即可</p>
<img src="/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16246301321799.png" class="" title="img">

<p>等待数分钟安装完成后，从开始菜单里找到ubuntu图标点击运行，第一次运行需要创建一个用户和密码，如下图所示：</p>
<img src="/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/ubuntuinstall.png" class="" title="Ubuntu unpacking in the Windows console">

<p>最后在powershell里运行以下命令，检查下是否为版本2，如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>
<img src="/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16246306952275.png" class="" title="img">

<p>考虑到root账户比较好用，可以将ubuntu启动的默认用户为root</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu config --set-user root</span><br></pre></td></tr></table></figure>
<h2 id="安装vscode"><a href="#安装vscode" class="headerlink" title="安装vscode"></a>安装vscode</h2><p>从<a target="_blank" rel="noopener" href="https://code.visualstudio.com/Download">这里</a>下载vscode，并进行安装</p>
<p>然后安装插件Remote - WSL</p>
<img src="/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16246308755039.png" class="" title="img">

<p>这个插件可以在win10下链接到子系统ubuntu下</p>
<h2 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h2><p>原来的cmd不好用，建议在Microsoft Store里安装一下windows terminal，可以通过windows terminal直接终端的方式访问ubuntu子系统。如下图所示：</p>
<img src="/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16246310732630.png" class="" title="img">

<p>在这个终端里可以折腾一些好用的工具，例如ohMyZsh，vim等。也可以根据习惯设置其主题。最重要的是，可以启动tmux来管理多个终端，当要访问服务器时，tmux非常nice。完全可以当做iterm2 + tmux来使用，win10也能当做mac一般方便开发。</p>
<h1 id="编译sqlite3"><a href="#编译sqlite3" class="headerlink" title="编译sqlite3"></a>编译sqlite3</h1><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>从github上下载想要查看的源码，链接是<a target="_blank" rel="noopener" href="https://github.com/sqlite/sqlite/releases">Releases · sqlite/sqlite (github.com)</a>，如果访问不了，那就去官网下载。建议下载分模块的代码，而不是汇总的代码。下图中红框的就是分模块的源码。未非模块的就只有sqlite3.h和sqlite3.c，所有逻辑都放到一块了。</p>
<img src="/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16246317134879.png" class="" title="img">

<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>ubuntu的编译比较简单：</p>
<ol>
<li><p>需要安装gcc， g++，gdb，执行<code> apt-get install build-essential gdb</code></p>
</li>
<li><p>解压sqlite.zip的代码，然后编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar xzf sqlite.tar.gz    ;#  Unpack the source tree into &quot;sqlite&quot;</span><br><span class="line">mkdir bld                ;#  Build will occur in a sibling directory</span><br><span class="line">cd bld                   ;#  Change to the build directory</span><br><span class="line">..&#x2F;sqlite&#x2F;configure  CFLAGS&#x3D;&#39;-g&#39; --enable-debug    ;#  Run the configure script</span><br><span class="line">make                     ;#  Run the makefile.</span><br><span class="line">make install             ;#  Install the sqlite3</span><br></pre></td></tr></table></figure>
<p>需要注意的是上面的configure，需要加两个配置，都是用来要求编译的动态库带上debug信息，方便后续debug sqlite源码时使用。</p>
</li>
</ol>
<p>编译时，需要使用libtool工具，因此可能需要提前安装下，执行以下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install automake libtool </span><br></pre></td></tr></table></figure>
<h1 id="调试sqlite3源码"><a href="#调试sqlite3源码" class="headerlink" title="调试sqlite3源码"></a>调试sqlite3源码</h1><h2 id="vscode插件安装"><a href="#vscode插件安装" class="headerlink" title="vscode插件安装"></a>vscode插件安装</h2><p>打开vscode，先链接上ubuntu子系统，会提示你安装vscode server。</p>
<p>然后open folder里打开sqlite的源码目录</p>
<img src="/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16246324019401.png" class="" title="img">

<p>代码如下图所示：</p>
<p>随便查看一个c文件，会提示你安装c/c++ 插件，点击确定即可。</p>
<img src="/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16246324903106.png" class="" title="img">



<h2 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h2><p>在src目录下创建一个c文件，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sqlite3.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">void</span> *NotUsed, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **azColName)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, azColName[i], argv[i] ? argv[i] : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sqlite3 *db;</span><br><span class="line">   <span class="keyword">char</span> *zErrMsg = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span>  rc;</span><br><span class="line">   <span class="keyword">char</span> *sql;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Open database */</span></span><br><span class="line">   rc = sqlite3_open(<span class="string">&quot;test.db&quot;</span>, &amp;db);</span><br><span class="line">   <span class="keyword">if</span>( rc )&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t open database: %s\n&quot;</span>, sqlite3_errmsg(db));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Opened database successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Create SQL statement */</span></span><br><span class="line">   sql = <span class="string">&quot;CREATE TABLE COMPANY(&quot;</span>  \</span><br><span class="line">         <span class="string">&quot;ID INT PRIMARY KEY     NOT NULL,&quot;</span> \</span><br><span class="line">         <span class="string">&quot;NAME           TEXT    NOT NULL,&quot;</span> \</span><br><span class="line">         <span class="string">&quot;AGE            INT     NOT NULL,&quot;</span> \</span><br><span class="line">         <span class="string">&quot;ADDRESS        CHAR(50),&quot;</span> \</span><br><span class="line">         <span class="string">&quot;SALARY         REAL );&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Execute SQL statement */</span></span><br><span class="line">   rc = sqlite3_exec(db, sql, callback, <span class="number">0</span>, &amp;zErrMsg);</span><br><span class="line">   <span class="keyword">if</span>( rc != SQLITE_OK )&#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;SQL error: %s\n&quot;</span>, zErrMsg);</span><br><span class="line">      sqlite3_free(zErrMsg);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Table created successfully\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   sqlite3_close(db);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后开始执行编译，快捷键是Ctrl+Shrift+B，实际上是目录的terminal-&gt;run Build Task。这个会在当前目录的.vscode下创建一个task.json文件，用来描述编译行为。注意，我们依赖sqlite3动态库，因此需要在args里添加一行”-lsqlite3”，不然会编译失败。</p>
<img src="/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16246329215768.png" class="" title="img">

<p>如下图所示：</p>
<p>也可以设置一个断点，然后按F5，或者Run-&gt;Start Debugging来启动调试功能。</p>
<img src="/2021/06/25/vscode-wsl-%E8%B0%83%E8%AF%95sqlite/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16246330559835.png" class="" title="img">

<p>这里需要注意的是，gdb可能链接的sqlite3动态库是，而这个库是不带debug信息的，导致debug时不会进入到sqlite的代码里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libsqlite3.so.0</span><br></pre></td></tr></table></figure>
<p>这个也只是个软连接，指向的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libsqlite3.so.0.8.6</span><br></pre></td></tr></table></figure>
<p>但是我们编译带debug信息的动态库安装的实际上是在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libsqlite3.so.0.8.6</span><br></pre></td></tr></table></figure>
<p>因此把之前的软连接删除，然后再把软连接链接到我们安装的动态库上即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libsqlite3.so.0.8.6 &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libsqlite3.so.0</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">Install WSL on Windows 10 | Microsoft Docs</a></li>
<li><a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a></li>
<li><a target="_blank" rel="noopener" href="https://sqlite.org/src/doc/trunk/README.md">SQLite: SQLite Source Repository</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/18/%E5%B7%A5%E4%B8%9A%E5%B9%B3%E5%8F%B0%E5%95%86%E4%B8%9A%E5%8C%96%E6%80%9D%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/18/%E5%B7%A5%E4%B8%9A%E5%B9%B3%E5%8F%B0%E5%95%86%E4%B8%9A%E5%8C%96%E6%80%9D%E8%B7%AF/" class="post-title-link" itemprop="url">工业平台商业化思路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-05-18 11:05:31 / 修改时间：11:19:25" itemprop="dateCreated datePublished" datetime="2021-05-18T11:05:31+08:00">2021-05-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="工业4-0"><a href="#工业4-0" class="headerlink" title="工业4.0"></a>工业4.0</h1><p>参考之前的文章</p>
<h1 id="商业化思路"><a href="#商业化思路" class="headerlink" title="商业化思路"></a>商业化思路</h1><h2 id="中立的第三方平台"><a href="#中立的第三方平台" class="headerlink" title="中立的第三方平台"></a>中立的第三方平台</h2><p>参考西门子Mindsphere平台。</p>
<p>西门子的数字化工厂集团（DF）致力于为企业提供全面的无缝集成软硬件和技术服务，帮助其提高制造流程的灵活性和效率，缩短产品上市时间，这一部门主要负责MindSphere。其解决方案前期用于自己，后期慢慢开始转为给客户提供服务。目前来看，数字化工厂营收逐步扩大，利润率稳定增长。</p>
<p>当前，在国内已经有海尔的COSMO Plat、美的的M.IoT、沈阳机床的SESOL、徐工机械的Xrea、三一集团的RootCloud等工业4.0平台，但无论是哪个平台，都不敢说自己已经对行业形成了深度影响。所以，巨头企业几经努力改造完成后的工业4.0解决方案，也可能只是自己一家企业的玩具。</p>
<p>其实，这类困境在互联网经济渗透的初期就曾经出现过。每当一家巨头企业希望搭建一个平台时，其一定绕不开一个质疑——凭什么让你又当运动员，又当裁判员？</p>
<p>另外，要做智能工厂的改造也没有那么容易，这不是装上传感器、加载几个软件模块、简单调试调试、训练好工人就能够成功的。甚至，在当前的技术条件下，有的行业的有些环节还依然脱离不了人工，根本无法进行工业4.0改造。</p>
<h2 id="从链接供需而推广自己的SaaS平台"><a href="#从链接供需而推广自己的SaaS平台" class="headerlink" title="从链接供需而推广自己的SaaS平台"></a>从链接供需而推广自己的SaaS平台</h2><p>参考智布互联。</p>
<ol>
<li>智布通过对纺织厂的深度调研发现，生产的精准和效率问题并不是这群客户真正的痛点，真正的痛点是获得订单。</li>
<li>进一步看，这是很多工业4.0赛道的企业没有走出来的误区，它们认为老板需要生产的精准和效率，这绝对正确，但让工业4.0的方案落地并不是由老板一个人决定的。在企业内部改变哪个生产环节都会无比艰难，因为企业的每个部分都会有现有机制和利益既得者来阻扰变革。结果往往是老板热情很高，员工比较消极，觉得新模式增加了自己的麻烦。</li>
<li>智布的逻辑是：“我们可以帮你们拉到订单，但你们必须用我们的SaaS系统。”当然，用了系统之后的好处也能够反映在平台的收益上，由于成本降低，中间环节差价变大，平台分佣自然增加。</li>
<li>工业4.0的未来从来就不是“单件定制”，而是“小批量大规模定制”，这是互联网渗透产业的不二法门。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>与高举高打的西门子和通用电气不同，智布这类小平台从行业切入，基于对行业的理解，做更轻量化、更接地气的解决方案，并在一个个里程碑之后，逐渐走入了深度赋能的模式。等到他们成熟了，我们会在行业里发现一个个的Mindsphere和Predix。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="http://www.woshipm.com/it/3877810.html">狂热过后才发现这条路最难走，工业4.0还有春天吗？ | 人人都是产品经理 (woshipm.com)</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/17/%E5%B7%A5%E4%B8%9ASaaS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/17/%E5%B7%A5%E4%B8%9ASaaS/" class="post-title-link" itemprop="url">工业SaaS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-17 17:56:49" itemprop="dateCreated datePublished" datetime="2021-05-17T17:56:49+08:00">2021-05-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-18 11:07:04" itemprop="dateModified" datetime="2021-05-18T11:07:04+08:00">2021-05-18</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="工厂生产概念"><a href="#工厂生产概念" class="headerlink" title="工厂生产概念"></a>工厂生产概念</h1><p>下图是工厂生产流程图。</p>
<img src="/2021/05/17/%E5%B7%A5%E4%B8%9ASaaS/gL2CA0s39vqIOnEmYIbg.png" class="" title="工业 SaaS 一定要懂的基础信息">

<h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a><strong>产品</strong></h2><p>但工业中需要注意的是产品的类型，有生产用料和非生产用料的区分。</p>
<ul>
<li><p>生产用料有原材料，半成品，成品；</p>
</li>
<li><p>非生产用料就是日常用品，比如办公桌，电脑等。</p>
</li>
</ul>
<p>我们重点在于生产用料的管理：</p>
<ul>
<li>如果是加工型工厂，一般是购进原材料，比如：一大片钢板加工成螺丝螺帽，没加工完的产品就是半成品，加工完了要出厂销售了一般是成品；</li>
<li>如果是组装型工厂，比如：小米电视买了一堆零部件过来组装，那采购来的就是半成品或者成品了。</li>
</ul>
<p>这里的产品和电商产品区别很大的是要经过加工，那么它就不是一个单纯的产品，它必须考虑到产品制造的物料清单和加工工艺。</p>
<img src="/2021/05/17/%E5%B7%A5%E4%B8%9ASaaS/lgAON3N6aSks1nGOeSZI.png" class="" title="工业 SaaS 一定要懂的基础信息">

<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a><strong>BOM</strong></h2><p>BOM（Bill of Material），即物料清单，也就是以数据格式来描述产品结构的文件。</p>
<p>BOM树长这样：</p>
<img src="/2021/05/17/%E5%B7%A5%E4%B8%9ASaaS/xBR9dnKpZgXb4HKXKzuu.png" class="" title="工业 SaaS 一定要懂的基础信息">

<p>但不同的阶段，BOM还有区分。</p>
<p>产品要经过工程设计、工艺制造设计、生产制造 3 个阶段，对应就是 EBOM（工程 BOM）、PBOM（计划 BOM）、DBOM（设计 BOM）。</p>
<ol>
<li>EBOM（工程 BOM）：通常仅限于图纸零件明细表出现的物料，说明图纸的层次和从属关系；做好技术文档管理，虽然也有指导采购和估算报价的功能，但主要是为了管理图纸。</li>
<li>PBOM（计划BOM）：是工艺工程师根据工厂的加工水平和能力，对EBOM再进行设计得出的；它用于工艺设计和生产制造管理，使用它可以明确地了解零件与零件之间的制造关系，跟踪零件是如何制造出来的，在哪里制造、由谁制造、用什么制造等信息。</li>
<li>设计BOM：DBOM是产品的总体信息，对应常见文本格式表现形式包括产品明细表、图样目录、材料定额明细表等等；是最终工人生产的依据，PLM中至少要包含这层。</li>
</ol>
<p><strong>BOM有什么用呢？</strong></p>
<p>我们看到上图的电动工具，由螺丝刀，充电器，批头组组成，但是批头组又由PE架，批头7件套组成，批头7件套又由批头组成，再往下，就是批头的加工过程了。</p>
<p>那工厂在生产的时候，是有加工和组装环节的，比如说有7个小组，每个小组分别生产批头1到批头7，都生产完了，组装组组成批头7件套，另一个组装部门再领出PE架，组装成批头组，再这样一步步往上。</p>
<p><strong>BOM 的作用就在于告诉工人你要干什么。</strong></p>
<p>对于工人来说，他们不关心最终产品是什么，他们只关心手头任务是什么，客户要电动工具，但分配到每个车间的任务是批头加工，批头组装等。</p>
<p>可以这样理解：BOM是工单任务拆分的重要依据，但作为工业的基础数据，它的作用肯定远不止如此。</p>
<p>客户下了销售订单，系统要根据现有在制品量、库存原材料量、加工产能等进行MRP运算，计算出还需采购多少原材料、最晚哪一天要到货、首车间什么时候投料、其他车间怎么排期；如果要外协，什么时候发出订单、什么时候要完成等等。</p>
<p>那么 MRP 运算就是基于BOM层层展开的（MRP是逻辑很复杂，但功能看似很简单的模块，这个后面再详细讲）。</p>
<p>最后还是回到追溯上，最后的产成品是要能根据 BOM 树，自上往下去找到每一个节点的。</p>
<p>知道了产品的物料清单，加工环节中另一个最重要的就是工艺了。</p>
<h2 id="工序、工艺、质检"><a href="#工序、工艺、质检" class="headerlink" title="工序、工艺、质检"></a><strong>工序</strong>、工艺、质检</h2><p>工艺流程亦称“加工流程”或“生产流程”——指通过一定的生产设备或管道，从原材料投入到成品产出，按顺序连续进行加工的全过程。</p>
<p>我们来看下面这张工艺卡片，里面包括了加工过程的每道工序、加工部门、所用设备、检测数据等；我们在系统设计时，工序、质检的数据肯定是单独维护的，但最终要被工艺引用到。</p>
<img src="/2021/05/17/%E5%B7%A5%E4%B8%9ASaaS/L655tfb1f0We296I7TbJ.png" class="" title="工业 SaaS 一定要懂的基础信息">

<p>实际的生产过程是这样的：</p>
<ol>
<li>工人在生产前，先点检下设备，就是查看下设备是不是好的，如果不好，就报修请人来修理，如果是好的，就开始今天的工作。</li>
<li>加工完成后，一般首个零件会先检查下，是否符合标准，在生产过程中，过段时间会抽检下，有质检员还会定时来巡检。</li>
<li>这道工序加工完了，就到下道工序。</li>
</ol>
<p>产品质量标准像下图这样：</p>
<img src="/2021/05/17/%E5%B7%A5%E4%B8%9ASaaS/nEusi47SjY7aKbx8EWHA.png" class="" title="工业 SaaS 一定要懂的基础信息">

<h2 id="标准作业指导书"><a href="#标准作业指导书" class="headerlink" title="标准作业指导书"></a>标准作业指导书</h2><p>将 BOM 和工艺结合起来，就是工厂编制的作业指导书。</p>
<p>看下图里面包含了所需物料和数量、作业流程、工序说明、技术要求、设备工具、检查要求等。</p>
<img src="/2021/05/17/%E5%B7%A5%E4%B8%9ASaaS/YtgB8BgyGg5yBZ6uufkk.png" class="" title="工业 SaaS 一定要懂的基础信息">

<p>我们回头想想，最开始工厂生产，可能就是这样的一份操作指导书，但是我们做到系统里时，把这个指导书进行了拆分，分成了 BOM、工序、工艺、设备、质检、人员等模块，独立的模块对于后续的数字化管理是更加方便的。</p>
<h2 id="工厂部门架构"><a href="#工厂部门架构" class="headerlink" title="工厂部门架构"></a>工厂部门架构</h2><p>一座典型工厂的部门架构、职能以及背后对应的价值链。</p>
<img src="/2021/05/17/%E5%B7%A5%E4%B8%9ASaaS/zh1sPuK7Vd4jarTa4WrF.jpeg" class="" title="img">

<h2 id="典型工业SaaS应用"><a href="#典型工业SaaS应用" class="headerlink" title="典型工业SaaS应用"></a>典型工业SaaS应用</h2><img src="/2021/05/17/%E5%B7%A5%E4%B8%9ASaaS/dZEwKgT94FOOXV5qVxO8.jpeg" class="" title="img">

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="http://www.woshipm.com/pd/4096466.html">工业 SaaS 一定要懂的基础信息 | 人人都是产品经理 (woshipm.com)</a></li>
<li><a target="_blank" rel="noopener" href="http://www.woshipm.com/it/3941692.html">当工业互联网遇上SaaS，说了10000次的新基建背后 | 人人都是产品经理 (woshipm.com)</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/14/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/14/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">工业大数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-14 11:11:13" itemprop="dateCreated datePublished" datetime="2021-05-14T11:11:13+08:00">2021-05-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-18 11:07:12" itemprop="dateModified" datetime="2021-05-18T11:07:12+08:00">2021-05-18</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-工业革命4-0"><a href="#1-工业革命4-0" class="headerlink" title="1. 工业革命4.0"></a>1. 工业革命4.0</h1><h2 id="1-1-时间线划分"><a href="#1-1-时间线划分" class="headerlink" title="1.1 时间线划分"></a>1.1 时间线划分</h2><h3 id="1-1-1-全球时间线"><a href="#1-1-1-全球时间线" class="headerlink" title="1.1.1 全球时间线"></a>1.1.1 全球时间线</h3><ol>
<li>2013年4月,全球国际工业博览会在德国汽车、机械、电子制造业中心汉诺威召开。会上,德国“工业4.0工作组”公布了研究成果报告《保障德国制造业的未来:关于实施“工业4.0”战略的建议》<a href="%E7%AE%80%E7%A7%B0%E5%BE%B7%E5%9B%BD%22%E5%B7%A5%E4%B8%9A4.0%22,%E5%90%8E%E6%96%87%E7%AE%80%E7%A7%B0%22%E5%B7%A5%E4%B8%9A4.0%22">1</a>,其目的是借助发挥德国制造业的传统优势,掀起新一轮制造技术的革命性创新与突破。报告的推出立即引起全球的广泛关注,产生了巨大的国际影响。</li>
<li>2014年，美国通用电气、IBM等科技巨头成立工业互联网联盟，开发和制定全新的工业技术和标准，重新定义互联网生态下的制造业，并响应和推动美国的“回归制造业”战略。</li>
<li>2015年5月,中国政府发布了《中国制造2025》(后文简称“制造2025”),提出要通过特殊政策和制度优势,突出创新驱动,依靠和发展高端装备制造业,打造中国品牌,形成中国创造,推出中国质量,完成中国由制造大国向制造强国的转变。</li>
</ol>
<h3 id="1-1-2-公认工业革命阶段"><a href="#1-1-2-公认工业革命阶段" class="headerlink" title="1.1.2 公认工业革命阶段"></a>1.1.2 公认工业革命阶段</h3><ol>
<li>18世纪60年代，人类社会发生了以蒸汽机为代表的第一代工业革命，大机器生产取代了手工劳动</li>
<li>19世纪70年代，自然科学开始同技术生产紧密结合起来，电力得到广泛应用，人类进入电气时代</li>
<li>20世纪50年代，原子能技术、航天技术、电子计算机应用、人工合成材料、分子生物等取得重大突破，科学技术有力推动了人类生产力的进度，形成了所谓的第三次工业革命</li>
</ol>
<h3 id="1-1-3-德国工业4-0小组的工业时代划分"><a href="#1-1-3-德国工业4-0小组的工业时代划分" class="headerlink" title="1.1.3 德国工业4.0小组的工业时代划分"></a>1.1.3 德国工业4.0小组的工业时代划分</h3><ol>
<li>1784年，以蒸汽机为动力的机械生产设备 导致了第一次工业革命</li>
<li>1870年，基于劳动分工的以电为动力的大规模生产带来了第二次工业革命</li>
<li>1969年，使用电子和信息技术让自动化程度更高</li>
<li>现在，基于信息物理融合系统的第四次工业革命开始</li>
</ol>
<h2 id="1-2-德国工业4-0主要内容"><a href="#1-2-德国工业4-0主要内容" class="headerlink" title="1.2 德国工业4.0主要内容"></a>1.2 德国工业4.0主要内容</h2><h3 id="1-2-1-一个核心"><a href="#1-2-1-一个核心" class="headerlink" title="1.2.1 一个核心"></a>1.2.1 一个核心</h3><p>“工业4.0”的核心是“智能+网络化”，即通过虚拟实体系统（CPS），构建智能工厂，实现智能制造的目的。通过大量部署各类传感元件实现信息的大量采集；将IT控件小型化与自主化，然后将其嵌入各类制造设备中，从而实现设备的智能化；依托通信技术达到数据的高速与无差错传输；对控制设备、制造设备的数据云存储和分析系统，从而达到生产过程的智能化以及方便人工实时控制的目的。</p>
<h3 id="1-2-2-两重战略"><a href="#1-2-2-两重战略" class="headerlink" title="1.2.2 两重战略"></a>1.2.2 两重战略</h3><p>一是“领先的供应商战略”，关注生产领域，要求德国的装备制造商必须遵循“工业4.0”的理念，产出具备“智能”与乐于“交流”的生产设备。该战略注重吸引中小企业的参与，希望它们不仅成为“智能生产”的使用者，也能化身为“智能生产”设备的供应者。这个关注的是智能工厂。</p>
<p>二是“领先的市场战略”，强调整个德国国内制造业市场的有效整合，构建遍布德国的高速互联网络是实现这一战略的关键。通过这一网络，德国的各类企业就能实现快速的信息共享、最终达成有效的分工合作。在此基础上，生产工艺可以重新定义与进一步细化，从而实现更为专业化的生产，提高德国制造业的生产效率。除了生产以外，商业企业也能与生产单位无缝衔接，进一步拉近德国制造企业与国内市场以及世界市场之间的距离。这个关注的是智能生产，能全产业链联合起来提供智能生产。</p>
<h3 id="1-2-3-三大集成"><a href="#1-2-3-三大集成" class="headerlink" title="1.2.3 三大集成"></a>1.2.3 三大集成</h3><p>一是关注产品的生产过程，力求在智能工厂内通过联网建成生产的纵向集成；</p>
<p>二是关注产品整个生命周期的不同阶段，包括设计与开发、安排生产计划、管控生产过程以及产品的售后维护等，实现各个不同阶段之间的信息共享，从而达成工程数字化集成；</p>
<p>三是关注全社会价值网络的实现，从产品的研究、开发与应用拓展至建立标准化策略、提高社会分工合作的有效性、探索新的商业模式以及考虑社会的可持续发展等，从而达成德国制造业的横向集成。</p>
<p>信息通信技术（ICT）是３大集成实现的保证，相关技术包括：机器对机器（M2M）技术，用于终端设备之间的数据交换；物联网（IoT）技术，将整个社会的人与物连接成一个巨大的网络；各类实现企业系统化管理的应用软件，如企业资源计划系统（ERP）、产品生命周期管理（PLM）、供应链管理（SCM）、系统生命周期管理（SysLM）等，这些系统进一步发挥协同的作用，成为企业进行智能化生产和管理的利器。</p>
<h3 id="1-2-4-八项行动举措"><a href="#1-2-4-八项行动举措" class="headerlink" title="1.2.4 八项行动举措"></a>1.2.4 八项行动举措</h3><p>一是实现技术标准化和开放标准的参考体系，制定参考架构的标准，促进企业之间网络的形成</p>
<p>二是建立模型来管理复杂的系统。</p>
<p>三是提供一套综合的工业宽带基础设施。</p>
<p>四是建立安全保障机制。</p>
<p>五是创新工作的组织和设计方式。</p>
<p>六是注重培训和持续的职业发展。</p>
<p>七是健全规章制度。</p>
<p>八是提升资源效率。</p>
<blockquote>
<p>“工业4.0”所说的资源，不仅包括原材料与能源，也涉及人力资源和财务资源。</p>
</blockquote>
<h1 id="2-术语概念"><a href="#2-术语概念" class="headerlink" title="2. 术语概念"></a>2. 术语概念</h1><h2 id="2-1-系统"><a href="#2-1-系统" class="headerlink" title="2.1 系统"></a>2.1 系统</h2><h3 id="ERP"><a href="#ERP" class="headerlink" title="ERP"></a>ERP</h3><p>（企业资源管理计划）——Enterprise Resources Plannig，是在先进的企业管理思想的基础上，应用信息技术实现对整个企业资源的一体化管理。ERP是一种可以提供跨地区、跨部门、甚至跨公司整合实时信息的企业管理信息系统。它在企业资源最优化配置的前提下，整合企业内部主要或所有的经营活动，包括财务会计、管理会计、生产计划及管理、物料管理、销售与分销等主要功能模块，以达到效率化经营的目标。</p>
<h3 id="MES"><a href="#MES" class="headerlink" title="MES"></a>MES</h3><p><a href="https://link.zhihu.com/?target=http://www.bjattn.com">MES制造执行系统</a>是一套面向制造企业车间执行层的生产信息化管理系统，主要针对于生产制造过程中流程、资源的管理系统，目标是实现生产制造过程“黑匣子”的可视、可控，为智能生产提供支撑。</p>
<h3 id="PLM"><a href="#PLM" class="headerlink" title="PLM"></a>PLM</h3><p>(product lifecycle management)系统，即产品全生命周期管理系统的简称。该系统以产品相关数据管理为核心，将企业资源、业务流程和产品数据集成起来，以产品的生命周期为主线，通过计算机软件对企业对产品相关的业务流程及数据进行统一管理和支配，从而帮助人们管理产品研发流程及所有资料，提升研发能力。</p>
<h3 id="HCM-HRM"><a href="#HCM-HRM" class="headerlink" title="HCM/HRM"></a>HCM/HRM</h3><p>人力资源管理</p>
<h3 id="CRM"><a href="#CRM" class="headerlink" title="CRM"></a>CRM</h3><p>（CustomerRelationshipManagement）就是客户关系管理。<br>从字义上看，是指企业用CRM来管理与客户之间的关系。 CRM是选择和管理有价值客户及其关系的一种商业策略，CRM要求以客户为中心的商业哲学和企业文化来支持有效的市场营销、销售与服务流程。如果企业拥有正确的领导、策略和企业文化，CRM应用将为企业实现有效的客户关系管理。</p>
<h3 id="SCM"><a href="#SCM" class="headerlink" title="SCM"></a>SCM</h3><p>(Supply Chain Management)就是对企业供应链的管理，是对供应、需求、原材料采购、市场、生产、库存、定单、分销发货等的管理，包括了从生产到发货、从供应商的供应商到顾客的顾客的每一个环节。</p>
<h3 id="EAM"><a href="#EAM" class="headerlink" title="EAM"></a>EAM</h3><p>(Enterprise Asset Management)是面向资产密集型企业的企业信息化解决方案的总称。它以提高资产可利用率、降低企业运行维护成本为目标，以优化企业维修资源为核心，通过信息化手段，合理安排维修计划及相关资源与活动。通过提高设备可利用率得以增加收益，通过优化安排维修资源得以降低成本，从而提高企业的经济效益和企业的市场竞争力。</p>
<h3 id="WMS"><a href="#WMS" class="headerlink" title="WMS"></a>WMS</h3><p>WMS是仓库管理系统(Warehouse Management System) 的缩写，是对物料存放空间进行管理的软件，区别于库存管理。其功能主要有两方面，一为通过在系统中设定一定的仓库仓位结构对物料具体空间位置的定位，二为通过在系统中设定一些策略对物料入库\出库\库内等作业流程进行指导。</p>
<p>仓库管理系统是通过入库业务、出库业务、仓库调拨、库存调拨和虚仓管理等功能，对批次管理、物料对应、库存盘点、质检管理、虚仓管理和即时库存管理等功能综合运用的管理系统，有效控制并跟踪仓库业务的物流和成本管理全过程，实现或完善的企业仓储信息管理。该系统可以独立执行库存操作，也可与其他系统的单据和凭证等结合使用，可为企业提供更为完整企业物流管理流程和财务管理信息。</p>
<h3 id="TMS"><a href="#TMS" class="headerlink" title="TMS"></a>TMS</h3><p>TMS是TransportationManagementSystem的英文缩写，意为运输管理系统。在管理软件中，以英文缩写命名的系统名称并不鲜见，TMS大部分只作为一个管理系统中的其中一个子系统来运用，主要在物流管理系统中，其主要功能是对物流环节中的运输环节的具体管理，包括车辆管理，在运途中货物的管理等。</p>
<h3 id="EMS"><a href="#EMS" class="headerlink" title="EMS"></a>EMS</h3><p>能源管理系统是以帮助工业生产企业在扩大生产的同时，合理计划和利用能源，降低单位产品能源消耗，提高经济效益，EMS能源管理系统主要对企业内部水、电、气等公共资源进行管理。</p>
<h3 id="OA"><a href="#OA" class="headerlink" title="OA"></a>OA</h3><p> 是Office Automation的缩写，指办公室自动化或自动化办公。</p>
<h3 id="PHM"><a href="#PHM" class="headerlink" title="PHM"></a>PHM</h3><p>故障预测与健康管理（PHM，Prognostics and Health Management）：利用工业系统中产生的各类数据，经过信号处理和数据分析等运算手段，实现对复杂工业系统的健康状态进行检测、预测和管理的系统性工程。PHM技术将设备的健康管理从传统的故障管理转变为衰退管理，通过预测性维护实现设备的零宕机和持续可靠的运行。</p>
<h3 id="APS"><a href="#APS" class="headerlink" title="APS"></a>APS</h3><p>APS高级计划系统（AdvancedPlanning System）或高级计划与排程(AdvancedPlanning and Scheduling)，分供应链级的APS和工厂级的APS。供应链级的APS侧重于SCP（Supply Chain Planning）供应链计划的优化，包括网络配置计划、需求计划、库存计划、多工厂计划、供应计划等的优化。工厂级的APS侧重于交期承诺、计划与排产、加工顺序调度、物料准时配送等的优化。</p>
<h3 id="SPC"><a href="#SPC" class="headerlink" title="SPC"></a>SPC</h3><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%9F%E8%AE%A1%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6">统计过程控制</a>（简称SPC）是一种借助数理统计方法的过程控制工具。它对生产过程进行分析评价，根据反馈信息及时发现系统性因素出现的征兆，并采取措施消除其影响，使过程维持在仅受随机性因素影响的受控状态，以达到控制质量的目的。</p>
<h3 id="TPM"><a href="#TPM" class="headerlink" title="TPM"></a>TPM</h3><p>TPM管理，即“全员生产维修”，70年代起源于日本，是一种全员参与的生产维修方式，其主要点就在“生产维修”及“全员参与”上。通过建立一个全系统员工参与的生产维修活动，使设备性能达到最优。</p>
<h2 id="2-2-名词解释"><a href="#2-2-名词解释" class="headerlink" title="2.2 名词解释"></a>2.2 名词解释</h2><h3 id="离散型制造业"><a href="#离散型制造业" class="headerlink" title="离散型制造业"></a>离散型制造业</h3><p>产品由多个零件经过一系列并不连续的工序加工而成，加工离散制造产品的行业称为离散型制造业（如机械制造业、汽车制造业、家电制造业）。典型特征是产品只是经过一些形状改变或组装而成。</p>
<h4 id="流程型制造业"><a href="#流程型制造业" class="headerlink" title="流程型制造业"></a>流程型制造业</h4><p>产品被不间断地通过生产设备及加工装置，进行化学或者物理变化，制造流程型制造产品的行业称为流程型制造业（如化工业、造纸业、钢铁业）。典型特征是产品会发生化学或物理变化。</p>
<h1 id="3-工业大数据"><a href="#3-工业大数据" class="headerlink" title="3. 工业大数据"></a>3. 工业大数据</h1><h2 id="3-1-愿景"><a href="#3-1-愿景" class="headerlink" title="3.1 愿景"></a>3.1 愿景</h2><ol>
<li>精度更高。能利用大数据分析错误，防止错误发生，提高制造成功率。</li>
<li>产量更高。利用大数据改进运营方式，同样的原材料下生成更多产品。</li>
<li>更好的预测。利用大数据有助于制造商更好地掌握这种淡旺季变化导致的供需关系的变化，因此可以在最有价值的生产条件下进行生产。</li>
<li>预测和跟踪供应商的产品优劣。利用大数据跟踪供应商的优劣，判断是否需要选择新的供应商具有成本效益。</li>
<li>更高的可追溯性。大数据可帮制造商跟踪生产和交付的所有这些阶段，并提供对可能效率低的领域的洞察和分析。</li>
</ol>
<h2 id="3-2-产业链"><a href="#3-2-产业链" class="headerlink" title="3.2 产业链"></a>3.2 产业链</h2><h3 id="3-2-1-产业链分析"><a href="#3-2-1-产业链分析" class="headerlink" title="3.2.1 产业链分析"></a>3.2.1 产业链分析</h3><p>下图是工业数据行业市场产业链分析，覆盖上中下游。</p>
<ol>
<li>上游，是软硬件服务商，提供传感器来采集数据，主要是国外厂商。云计算服务提供商，国内已经达到一流水平。</li>
<li>中游，大数据服务商，国内也诞生了一批大数据服务提供商。</li>
<li>下游，不同行业制造商<img src="/2021/05/14/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_1620982571701-1620983043861-1620983046185.png" class="" title="img"></li>
</ol>
<h3 id="3-2-2-市场规模"><a href="#3-2-2-市场规模" class="headerlink" title="3.2.2 市场规模"></a>3.2.2 市场规模</h3>  <img src="/2021/05/14/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16209837694242.png" class="" title="img">

<h3 id="3-2-3-产品结构"><a href="#3-2-3-产品结构" class="headerlink" title="3.2.3 产品结构"></a>3.2.3 产品结构</h3><img src="/2021/05/14/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16209838435228.png" class="" title="img">

<h2 id="3-3-技术分析"><a href="#3-3-技术分析" class="headerlink" title="3.3 技术分析"></a>3.3 技术分析</h2><h3 id="3-3-1-数据分类和特征"><a href="#3-3-1-数据分类和特征" class="headerlink" title="3.3.1 数据分类和特征"></a>3.3.1 数据分类和特征</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>根据数据来源分类</p>
<ol>
<li>第一类是企业运营管理相关的业务数据。这类数据来自企业信息化范畴，包 括企业资源计划(ERP)、产品生命周期管理(PLM)、供应链管理(SCM)、客户关系 管理(CRM)和能耗管理系统（EMS)等，此类数据是工业企业传统意义上的数据资4 产。</li>
<li> 第二类是制造过程数据。主要是指工业生产过程中，装备、物料及产品加工 过程的工况状态参数、环境参数等生产情况数据，通过 MES 系统实时传递，目 前在智能装备大量应用的情况下，此类数据量增长最快。 </li>
<li>第三类是企业外部数据。包括工业企业产品售出之后的使用、运营情况的数 据，同时还包括大量客户名单、供应商名单、外部的互联网等数据。</li>
</ol>
<p>下表是一些常见的数据源及特征。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>系统类型</th>
<th>典型系统</th>
<th>数据结构</th>
<th>数据特点</th>
<th>实时性</th>
</tr>
</thead>
<tbody><tr>
<td>管理系统</td>
<td>设计资料</td>
<td>产品模型、图纸文档</td>
<td>半结构化/ 非结构化</td>
<td>类型各异、更新不 频繁、是企业核心 数据</td>
<td>批量导入</td>
</tr>
<tr>
<td></td>
<td>价值链管 理</td>
<td>供应链 SCM、客户关 系 CRM</td>
<td>结构化/半 结构化</td>
<td>没有严格的时效性 要求，需要定期同 步</td>
<td>批量导入</td>
</tr>
<tr>
<td></td>
<td>资源管理</td>
<td>ERP/OA、MES、 PLM、环境管理系 统、仓库管理系统、 能源管理系统</td>
<td>结构化</td>
<td>没有严格的时效性 要求，需要定期同 步</td>
<td>批量导入</td>
</tr>
<tr>
<td>生产系统</td>
<td>工业控制 系统</td>
<td>DCS、PLC</td>
<td>结构化</td>
<td>需要实时监控，实时反馈控制</td>
<td>实时采集</td>
</tr>
<tr>
<td></td>
<td>生产监控 数据</td>
<td>SCADA</td>
<td>结构化</td>
<td>包含实时数据和历 史数据</td>
<td>实时采集/批量 导入</td>
</tr>
<tr>
<td></td>
<td>各类传感 器</td>
<td>外挂式传感器、条 码、射频识别</td>
<td>结构化</td>
<td>单条数据量小，并 发度大，结合 IoT 网关</td>
<td>实时采集</td>
</tr>
<tr>
<td></td>
<td>其他外部 装置</td>
<td>视频摄像头</td>
<td>非结构化</td>
<td>数据量大、低时 延，要求网络带宽 和时延</td>
<td>实时采集</td>
</tr>
<tr>
<td>外部 数据</td>
<td>外部数据</td>
<td>相关行业、法规、市 场、竞品、环境数据</td>
<td>非结构化</td>
<td>数据相对静止，变 化较小，定期更新</td>
<td>批量导入</td>
</tr>
</tbody></table>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ol>
<li> 数据容量大（volume）：数据的大小 决定所考虑的数据的价值和潜在的信息。工业数据体量比较大，大量机器设备的高频数 据和互联网数据持续涌入，大型工业企业的数据集将达到PB级甚至EB级别。 </li>
<li> 多样（variety）：指数据类型的多样 性和来源广泛。工业数据分布广泛，分布于机器设备、工业产品、管理系统、互联网等各个环节，并且结构复杂，既有结构化和半结构化的传感数据，也有非结构化数据。 </li>
<li>快速（velocity）：指获得和处理数据的速度。工业数据处理速度需求多样， 生产现场级要求分析时限达到毫秒级，管理与决策应用需要支持交互式或批量数据分析。 </li>
<li>价值密度低（value）：工业大数据更强调用户价值驱动和数据本身的可用性， 包括：提升创新能力和生产经营效率及促 进个性化定制、服务化转型等智能制造新 模式变革。 </li>
<li>时序性（sequence）：工业大数据具有较强的时序性，如订单、设备状态数 据等。 </li>
<li>强关联性（strong-relevance）：一 方面，产品生命周期同一阶段的数据具有 强关联性，如产品零部件组成、工况、设备 状态、维修情况、零部件补充采购等；另一 方面，产品生命周期的研发设计、生产、服 务等不同环节的数据之间需要进行关联。 </li>
<li>准确性（accuracy）：主要指数据 的真实性、完整性和可靠性，更加关注数据质量以及处理、分析技术和方法的可靠 性。对数据分析的置信度要求较高，仅依靠统计相关性分析不足以支撑故障诊断、 预测预警等工业应用，需要将物理模型与数据模型结合，挖掘因果关系。</li>
<li>闭环性（closed-loop）：包括产品全 生命周期横向过程中数据链条的封闭和关 联以及智能制造纵向数据采集和处理过程 中，需要支撑状态感知、分析、反馈、控制 等闭环场景下的动态持续调整和优化</li>
</ol>
<h3 id="3-3-2-技术架构"><a href="#3-3-2-技术架构" class="headerlink" title="3.3.2 技术架构"></a>3.3.2 技术架构</h3><p>如下图所示，是大数据技术架构白皮书中提出的工业大数据平台技术架构。涉及七项核心技术：</p>
<ol>
<li>数据集成与边缘处理技术 <ol>
<li>设备接入：基于工业以太网、工业总线等工业通信协议，以 太网、光纤等通用协议，3G/4G、NB-IOT 等无线协议将工业现场设备接入到平台边缘层。</li>
<li>协议转换：一方面运用协议解析、中间件等技术兼容 ModBus、 OPC、CAN、Profibus 等各类工业通信协议和软件通信接口，实现数据格式转换和统一。另一方面利用 HTTP、MQTT 等方式从边缘侧将采集到的数据传输到云端，实现数据的远程接入。</li>
<li>边缘数据处理：基于高性能计算芯片、实时操作系统、边缘分析算法等技术支撑，在靠近设备或数据源头的网络边缘侧进行数据预处理、存储以及智能分析应用，提升操作响应灵敏度、消除网络堵塞，并与云端分析形成协同。</li>
</ol>
</li>
<li>IaaS 技术 <ol>
<li>基于虚拟化、分布式存储、并行计算、负载调度等技术，实现网络、计算、存储等计算机资源的池化管理，根据需求进行弹性分配，并确保资源使用的安全与隔离，为用户提供完善的云基础设施服务。 </li>
</ol>
</li>
<li>平台使能技术<ol>
<li>资源调度：通过实时监控云端应用的业务量动态变化，结合相应的调度算法为应用程序分配相应的底层资源，从而使云端应用可以自动适应业务量的变化。</li>
<li> 多租户管理：通过虚拟化、数据库隔离、容器等技术实现不同租户应用和服务的隔离，保护其隐私与安全。</li>
</ol>
</li>
<li>数据管理技术 <ol>
<li>数据处理框架：借助 Hadoop、Spark、Storm 等分布式处理架构，满足海量数据的批处理和流处理计算需求。 </li>
<li>数据预处理：运用数据冗余剔除、异常检测、归一化等方法对原始数据进行清洗，为后续存储、管理与分析提供高质量数据来源。 </li>
<li>数据存储与管理：通过分布式文件系统、NoSQL 数据库、关系数据库、时序数据库等不同的数据管理引擎实现海量工业数据的分区选择、存储、编目与索引等。</li>
</ol>
</li>
<li>应用开发和微服务技术 <ol>
<li>多语言与工具支持：支持 Java,Ruby 和 PHP 等多种语言编译环境，并提供 Eclipse integration，JBoss Developer Studio、 git 和 Jenkins 等各类开发工具，构建高效便捷的集成开发环 境。 </li>
<li>微服务架构：提供涵盖服务注册、发现、通信、调用的管理 机制和运行环境，支撑基于微型服务单元集成的“松耦合”应用 开发和部署。 </li>
<li>图形化编程：通过类似 Labview 的图形化编程工具，简化开 发流程，支持用户采用拖拽方式进行应用创建、测试、扩展等。 </li>
</ol>
</li>
<li>工业数据建模与分析技术<ol>
<li> 数据分析算法：运用数学统计、机器学习及最新的人工智能 算法实现面向历史数据、实时数据、时序数据的聚类、关联和预 测分析。 </li>
<li>机理建模：利用机械、电子、物理、化学等领域专业知识，10 结合工业生产实践经验，基于已知工业机理构建各类模型，实现分析应用。 </li>
</ol>
</li>
<li>安全技术数据<ol>
<li>接入安全：通过工业防火墙技术、工业网闸技术、加密 隧道传输技术，防止数据泄漏、被侦听或篡改，保障数据在源头和传输过程中安全。 </li>
<li>平台安全：通过平台入侵实时检测、网络安全防御系统、恶意代码防护、网站威胁防护、网页防篡改等技术实现工业互联网 平台的代码安全、应用安全、数据安全、网站安全。</li>
<li> 访问安全：通过建立统一的访问机制，限制用户的访问权限 和所能使用的计算资源和网络资源实现对云平台重要资源的访 问控制和管理, 防止非法访问。</li>
</ol>
</li>
</ol>
<img src="/2021/05/14/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84.png" class="" title="工业互联网平台技术架构">



<p>下面是从服务商角度来做技术体系划分：</p>
<ol>
<li>边缘层，包括各种设备、生产系统</li>
<li>网络层，包括工厂车间内部的网络通信、工厂数据与大数据中心的网络通信</li>
<li>数据层，主要是提供基础计算、存储、网络资源，可以看做IaaS层</li>
<li>平台层，提供支持工业数据的存储 、建模、分析等，可以看做PaaS层（下图有点不太准）</li>
<li>应用层，工业相关的应用软件，可以看做SaaS层，涉及到不同行业不同生产阶段的功能需求</li>
<li>安全层，提供多种安全机制，保障数据安全</li>
</ol>
<img src="/2021/05/14/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16211553432886.png" class="" title="img">

<p><strong>下面是按不同层次的服务提供商划分，下图比上图要准确一些。</strong></p>
<img src="/2021/05/14/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_1621155029325.png" class="" title="img">



<h3 id="3-3-3-数据采集"><a href="#3-3-3-数据采集" class="headerlink" title="3.3.3 数据采集"></a>3.3.3 数据采集</h3><h4 id="按数据类型分类"><a href="#按数据类型分类" class="headerlink" title="按数据类型分类"></a>按数据类型分类</h4><ol>
<li>海量的Key-Value数据。在传感器技术飞速发展的今天，包括光电、热敏、气敏、力敏、磁敏、声敏、湿敏等不同类别的工业传感器在现场得到了大量应用，而且很多时候机器设备的数据大概要到ms的精度才能分析海量的工业数据，因此，这部分数据的特点是每条数据内容很少，但是频率极高。</li>
<li>文档数据。包括工程图纸、仿真数据、设计的CAD图纸等，还有大量的传统工程文档。</li>
<li>信息化数据。由工业信息系统产生的数据，一般是通过数据库形式存储的，这部分数据是最好采集的。</li>
<li>接口数据。由已经建成的工业自动化或信息系统提供的接口类型的数据，包括txt格式、JSON格式、XML格式等。</li>
<li>视频数据。工业现场会有大量的视频监控设备，这些设备会产生大量的视频数据。</li>
<li>图像数据。包括工业现场各类图像设备拍摄的图片（例如，巡检人员用手持设备拍摄的设备、环境信息图片）。</li>
<li>音频数据。包括语音及声音信息（例如，操作人员的通话、设备运转的音量等）。</li>
<li>其他数据。例如遥感遥测信息、三维高程信息等等。</li>
</ol>
<h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ol>
<li>数据量巨大。工业大数据量大，并且大量的工业数据是“脏”数据，直接存储无法用于分析，在存储之前，必须进行处理，对海量的数据进行处理，从技术上又提高了难度。</li>
<li>工业数据的协议不标准。互联网数据采集一般都是我们常见的HTTP等协议，但在工业领域，会出现ModBus、OPC、CAN、ControlNet、DeviceNet、Profibus、Zigbee等等各类型的工业协议，而且各个自动化设备生产及集成商还会自己开发各种私有的工业协议，导致在工业协议的互联互通上，出现了极大地难度。</li>
<li>视频传输所需带宽巨大，大量视频数据上公有云带宽非常大</li>
<li>对原有系统的采集难度大。采集的是已经完成部属的自动化系统上位机数据，这些自动化系统在部署时厂商水平参差不齐，大部分系统是没有数据接口的，文档也大量缺失，大量的现场系统没有点表等基础设置数据，使得对于这部分数据采集的难度极大。</li>
<li>安全性考虑不足。原先的工业系统都是运行在局域网中，安全问题不是突出考虑的重点。一旦需要通过云端调度工业之中最为核心的生产能力，又没有对安全的充分考虑，造成损失，是难以弥补的。</li>
</ol>
<h3 id="3-3-4-数据存储管理和计算能力"><a href="#3-3-4-数据存储管理和计算能力" class="headerlink" title="3.3.4 数据存储管理和计算能力"></a>3.3.4 数据存储管理和计算能力</h3><h4 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h4><table>
<thead>
<tr>
<th>类型</th>
<th>典型系统</th>
<th>试用场景</th>
</tr>
</thead>
<tbody><tr>
<td>海量低成本存储</td>
<td>对象存储、云盘</td>
<td>海量历史数据的归档和备份</td>
</tr>
<tr>
<td>分布式文件系统</td>
<td>HDFS</td>
<td>海量数据的离线存储</td>
</tr>
<tr>
<td>数据仓库</td>
<td>MPP、Hive</td>
<td>报表综合分析、多维随机分析</td>
</tr>
<tr>
<td>NoSQL数据库</td>
<td>HBase、MongoDB</td>
<td>各类报表文档，使用于简单对点查询及交互式查询场景</td>
</tr>
<tr>
<td>关系型数据库</td>
<td>MySQL、PostgreSQL、Oracle</td>
<td>适用于交互式查询分析</td>
</tr>
<tr>
<td>时序数据库</td>
<td>InfluxDB、Apache IoTDB、KDB+</td>
<td>依据时间顺序分析历史趋势、周期规律、异常性等场景</td>
</tr>
<tr>
<td>内存数据库</td>
<td>Redis、Memcached</td>
<td>数据量不大且要求快速实时查询场景</td>
</tr>
<tr>
<td>图数据库</td>
<td>Neo4j、HugeGraph</td>
<td>分析关联关系及具有明显点、边分析的场景</td>
</tr>
<tr>
<td>文本数据索引</td>
<td>Solr、Elasticsearch</td>
<td>文本/全文检索</td>
</tr>
</tbody></table>
<h4 id="计算能力"><a href="#计算能力" class="headerlink" title="计算能力"></a>计算能力</h4><table>
<thead>
<tr>
<th>类型</th>
<th>典型系统</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>实时计算引擎</td>
<td>Storm、Flink、Spark Streaming</td>
<td>设备监控、实时诊断等对时效性要求较高的场景</td>
</tr>
<tr>
<td>离线计算引擎</td>
<td>MapReduce、Spark、Hive</td>
<td>适用于大数据量的，周期性的数据分析，例如阶段性的营销分析，或生产能耗分析等</td>
</tr>
<tr>
<td>图计算引擎</td>
<td>GraphLab、GraphX</td>
<td>适用于事件及人之间的关联分析，比如建立用户画像进行个性化定制或营销</td>
</tr>
<tr>
<td>数据综合分析OLAP</td>
<td>MPP</td>
<td>产线或销售环节的综合报表分析</td>
</tr>
<tr>
<td>业务交互查询OLTP</td>
<td>MySQL、PostgreSQL、Oracle</td>
<td>交互式查询分析</td>
</tr>
<tr>
<td>分布式数据库中间件</td>
<td>Cobar、TTDL、MyCAT</td>
<td>海量数据搞并发时的弹性扩容解决方案</td>
</tr>
<tr>
<td>数据挖掘能力</td>
<td>Spark、TensorFlow</td>
<td>需要迭代优化的数据挖掘场景，如故障预测、用户需求挖掘等</td>
</tr>
</tbody></table>
<h3 id="3-3-5-数据应用分析"><a href="#3-3-5-数据应用分析" class="headerlink" title="3.3.5 数据应用分析"></a>3.3.5 数据应用分析</h3><h4 id="时序模式分析技术"><a href="#时序模式分析技术" class="headerlink" title="时序模式分析技术"></a>时序模式分析技术</h4><p>传感器数据的很多重要信息是隐藏在时序模式结 构中，只有挖掘出背后的结构模式，才能构建一个效果稳定的数据模型。</p>
<p>工时序数据的时间序列类算法主要分六个方面：</p>
<ol>
<li>时间序列的预测算法如 ARIMA，GARCH 等；</li>
<li>时间序列的异常变动模式检测算法，包含基于统计的方法、 基于滑动窗窗口的方法等；</li>
<li>时间序列的分类算法，包括 SAX 算法、基于相似度的 方法等；</li>
<li>时间序列的分解算法，包括时间序列的趋势特征分解、季节特征分解、 周期性分解等；</li>
<li>时间序列的频繁模式挖掘，典型时序模式智能匹配算法（精准匹 配、保形匹配、仿射匹配等），包括 MEON 算法、基于 motif 的挖掘方法等；</li>
<li>时间序列的切片算法，包括 AutoPlait 算法、HOD-1D 算法等。</li>
</ol>
<p>工业大数据分析的一个重要应用方向是对机器设备的故障预警和故障诊断， 其中设备的振动分析是故障诊断的重要手段。设备的振动分析需要融合设备机理 模型和数据挖掘技术，针对旋转设备的振动分析类算法主要分成三类：</p>
<ol>
<li>振动数据的时域分析算法，主要提取设备振动的时域特征，如峭度、斜度、峰度系数等；</li>
<li> 振动数据的频域分析算法，主要从频域的角度提取设备的振动特征，包括高阶谱 算法、全息谱算法、倒谱算法、相干谱算法、特征模式分解等；</li>
<li>振动数据的时频分析算法，综合时域信息和频域信息一种分析手段，对设备的故障模型有较好的 提取效果，主要有短时傅里叶变换、小波分析等</li>
</ol>
<h4 id="工业知识图谱技术"><a href="#工业知识图谱技术" class="headerlink" title="工业知识图谱技术"></a>工业知识图谱技术</h4><p>工业生产过程中会积累大量的日志文本，如维修工单、工艺流程文件、故障记录等，此类非结构化数据中蕴含着丰富的专家经验，利用文本分析的技术能够 实现事件实体和类型提取（故障类型抽取）、事件线索抽取（故障现象、征兆、 排查路线、结果分析），通过专家知识的沉淀实现专家知识库（故障排查知识库、 运维检修知识库、设备操作知识库）。 针对文本这类的非结构化数据，数据分析领域已经形成了成熟的通用文本挖 掘类算法，包括分词算法（POS tagging、实体识别）、关键词提取算法（TD-IDF)、 词向量转换算法、词性标注算法（CLAWS、VOLSUNGA）、主题模型算法（如 LDA） 等。但在工业场景中，这些通用的文本分析算法，由于缺乏行业专有名词（专业 术语、厂商、产品型号、量纲等）、语境上下文（包括典型工况描述、故障现象 等），分析效果欠佳。这就需要构建特定领域的行业知识图谱（即工业知识图谱）， 并将工业知识图谱与结构化数据图语义模型融合，实现更加灵活的查询和一定程度上的推理。</p>
<h4 id="多源数据融合分析技术"><a href="#多源数据融合分析技术" class="headerlink" title="多源数据融合分析技术"></a>多源数据融合分析技术</h4><p>在企业生产经营、营销推广、采购运输等环节中，会有大量的管理经营数据， 其中包含着众多不同来源的结构化和非结构化数据，例如来源于企业内部信息系 统（CRM、MES、ERP、SEM）的生产数据、管理数据、销售数据等，来源于企业外 部的物流数据、行业数据、政府数据等。利用这些数据可实现市场洞察、价格预测、供应链协同、精准销售、市场调度、产品追溯、能力分析、质量管控等等。 通过对这些数据的分析，能够极大的提高企业的生产加工能力、质量监控能力、 企业运营能力、市场营销能力、风险感知能力等。</p>
<p>但多源数据也带来一定的技术挑战，不同数据源的数据质量和可信度存在差异，并且在不同业务场景下的表征 能力不同。这就需要一些技术手段去有效融合多源数据。 </p>
<p>针对多源数据分析的技术主要包括：统计分析算法、深度学习算法、回归算法、分类算法、聚类算法、关联规则等。可以通过不同的算法对不同的数据源进行独立的分析，并通过对多个分析结果的统计决策或人工辅助决策，实现多源融合分析。也可以从分析方法上实现融合，例如通过非结构化文本数据语义融合构 建具有制造语义的知识图谱，完成其他类型数据的实体和语义标注，通过图模型 从语义标注中找出跨领域本体相互间的关联性，可以用于识别和发现工业时序数 据中时间序列片段对应的文本数据（维修报告）上的故障信息，实现对时间序列 的分类决策</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ol>
<li>工业大数据大有可为，而且时间跨度会很长，影响接下来的可能跨越数十年的工业化发展。</li>
<li>考虑到当前很多制造业企业甚至连数据中心都没有，而且又不想把数据放入到公有云环境中。因此如果自己搭建一套工业大数据平台，可以对上述的技术架构进行裁减。将大数据平台划分为以下5层：<ol>
<li>边缘层，工厂各种设备的数据采集 ，这里一般需要涉及到对不同传感器、生产系统的数据读取或订阅操作，并将采集数据通过网络协议上传到大数据平台中</li>
<li>平台层，直接物理部署的大数据平台<ol>
<li>通过消息队列来统一接入不同设备、不同协议的数据</li>
<li>针对不同类型的数据采用不同的数据存储技术，将数据管理起来，并提供多种大数据计算能力给应用层</li>
</ol>
</li>
<li>建模分析层，使用平台层的数据和计算能力，提供数据建模、数据分析、数据可视化、知识库能力、统计分析、规则引擎等数据分析工具。</li>
<li>应用层，基于数据分析结果，生成描述、诊断、预测、决策、控制等不同应用，对生产系统做各种优化（例如供应链优化、设备预测检修等）</li>
<li>安全层，提供访问控制安全，数据安全等能力</li>
</ol>
</li>
<li>工业大数据的技术链路很长，想要获得好的发展，对接好上下游的生态非常重要。</li>
</ol>
<h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><ol>
<li>[1]李金华. 德国”工业4.0”与”中国制造2025”的比较及启示[J]. 中国地质大学学报:社会科学版, 2015, 015(005):71-79.</li>
<li>[1]郑树泉, 覃海焕, 王倩. 工业大数据技术与架构[J]. 大数据, 2017, 003(004):67-80.</li>
<li>《工业4.0:即将来袭的第四次工业革命》</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62589639">【管理4.0 】第四次工业革命与工业4.0 - 知乎 (zhihu.com)</a></li>
<li><a target="_blank" rel="noopener" href="http://xkzj.mofcom.gov.cn/article/myszh/szhzx/202012/8589.html">中华人民共和国商务部配额许可证事务局 (mofcom.gov.cn)</a></li>
<li><a target="_blank" rel="noopener" href="http://qccdata.qichacha.com/ReportData/PDF/fce27a1408c9b71ddb0bfea0528f10c5.pdf">2020年中国工业大数据行业概览</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cesi.cn/images/editor/20190401/20190401145953698.pdf">工业大数据白皮书</a></li>
<li><a target="_blank" rel="noopener" href="http://www.todayim.cn/download/%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E4%B8%9A%E5%8F%91%E5%B1%95%E8%81%94%E7%9B%9F%EF%BC%88AII%EF%BC%89/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E7%99%BD%E7%9A%AE%E4%B9%A6.pdf">工业大数据技术架构白皮书.pdf (todayim.cn)</a></li>
<li><a target="_blank" rel="noopener" href="https://pdf.dfcfw.com/pdf/H3_AP202011101427888212_1.pdf?1605000779000.pdf">亿欧智库-2020工业互联网行业产业研究报告：服务商案例集-201109.pdf (dfcfw.com)</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/07/OpenTSDB%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/07/OpenTSDB%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">OpenTSDB入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-07 15:17:11" itemprop="dateCreated datePublished" datetime="2021-02-07T15:17:11+08:00">2021-02-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-19 11:21:59" itemprop="dateModified" datetime="2021-04-19T11:21:59+08:00">2021-04-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>以下是官网介绍。</p>
<blockquote>
<p>OpenTSDB是一个基于HBase的分布式的、可伸缩的时间序列数据库（TSDB）。OpenTSDB是为了监控而生，例如对从大规模集群（包括网络设备、操作系统、应用程序等）采集到的监控数据进行存储，并使这些数据易于访问并且容易图形化的。</p>
<p>由于HBase的可伸缩性，OpenTSDB允许收集来自上万台主机和应用程序的成千上万的高频率数据（每隔几秒钟）。OpenTSDB永远不会删除或减少采样数据，并且可以轻松存储数千亿个数据点。</p>
</blockquote>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p><strong>TSD</strong></p>
<p>时间序列守护进程，负责和HBase交互进行数据存储和查询。</p>
<p><strong>Epoch</strong></p>
<p>时间戳的数值表示，有两种格式：</p>
<ol>
<li>10位数字表示的，从1970年1月1日起经过的秒数</li>
<li>13位数字表示的，从1970年1月1日起经过的毫秒数</li>
</ol>
<p><strong>Metric</strong></p>
<p>指标，或者说监控项，例如监控一个人的心跳速率，那么心跳速率就是metric；而监控一个公司的股票，股票价格就是metric。</p>
<p><strong>Tags</strong></p>
<p>tag可以理解为时序数据点的注释。一个tag描述的是一个metric的某个属性。Tags是key-value对，每个数据点可以有多个tag。例如监控一个病人的心率，患者的姓名成为tag，区分每个患者的数据。这里，“心率”是metic，“姓名”是tag，“托马斯”是患者的姓名，是标签的值。其他标签可以是“年龄”、“性别”。标签值用于在查询时过滤/聚合数据。</p>
<p><strong>降采样DownSampling</strong></p>
<p>降采样是降低数据采样率或分辨率的过程。如果查询的数据持续时间较长，则接收到的点数将很高，这将导致查询吞吐量较慢。例如，如果数据每秒存储一次而我们查询一周的数据，我们将得到604800个数据点。如果我们对数据进行下采样成每隔一分钟存储一次，就得到10080个数据。这减少了查询时间、网络延迟和系统的总体负载。</p>
<p><strong>集合Aggregation</strong></p>
<p>聚合是多个数据的集合。OpenTSDB被设计成在查询执行期间有效地组合多个不同的时间序列。例如，如果我们希望看到所有男性患者的平均心率，那么我们使用平均值函数作为聚合函数来聚合男性患者的所有时间序列数据。这将给我们一组点，显示所有男性患者的平均心率。</p>
<p><strong>插值Interpolation</strong></p>
<p>为了使聚合工作，我们需要为查询的时间范围提供数据。如果我们以分钟级别聚合数据，则每分钟需要60个数据点。但在现实世界中，数据很有可能存在丢失。OpenTSDB使用插值来填补这些空白。例如，对于“zimsum”类型的聚合，OpenTSDB通过为所有缺失值填充0进行插值，然后通过对数据求和进行聚合。</p>
<p><strong>Cardinality</strong></p>
<p>基数，在数学中定义为一个集合中的一些元素，在数据库中定义为一个索引的一些唯一元素，在OpenTSDB定义为：</p>
<ul>
<li>一个给定指标的一些唯一时间序列</li>
<li>和一个标签名称相关联的一些唯一标签值</li>
</ul>
<p><strong>Compaction</strong></p>
<p>在OpenTSDB中，会将多列合并到一列之中以减少磁盘占用空间，这和hbase中的Compaction不一样。这个过程会在TSD写数据或者查询过程中不定期的发生。</p>
<p><strong>Data Point</strong></p>
<p>每一个指标可以被记录为某一个时间点的一个数值。Data Point包括以下部分：</p>
<ul>
<li>一个指标：metric</li>
<li>一个数值</li>
<li>这个数值被记录的时间戳</li>
<li>多个标签</li>
</ul>
<p><strong>Time Series</strong></p>
<p>一个metric的带有多个tag的data point集合。</p>
<p><strong>UID</strong></p>
<p>在OpenTSDB中，每一个metric、tagk或者tagv在创建的时候被分配一个唯一标识叫做UID，他们组合在一起可以创建一个序列的UID或者<code>TSUID</code>。在OpenTSDB的存储中，对于每一个metric、tagk或者tagv都存在从0开始的计数器，每来一个新的metric、tagk或者tagv，对应的计数器就会加1。当data point写到TSD时，UID是自动分配的。你也可以手动分配UID，前提是<code>auto metric</code>被设置为true。默认地，UID被编码为3Bytes，每一种UID类型最多可以有16,777,215个UID。你也可以修改源代码改为4Bytes。UID的展示有几种方式，最常见的方式是通过http api访问时，3 bytes的UID被编码为16进制的字符串。例如，UID为1的写为二进制的形式为<code>000000000000000000000001</code>，如果表示为一个无符号的byte数组，其可以表示为<code>[0,0,1]</code>，编码为16进制字符串为<code>000001</code>,其中每一位左边都被补上0,如果其不足两位。故，UID为255的会显示为<code>[0,0,255]</code>和<code>0000FF</code>。</p>
<p><strong>TSUID</strong></p>
<p>当一个data point被写到OpenTSDB时，其row key格式为：<code>&lt;metric_UID&gt;&lt;timestamp&gt;&lt;tagk1_UID&gt;&lt;tagv1_UID&gt;[...&lt;tagkN_UID&gt;&lt;tagvN_UID&gt;]</code>，不考虑时间戳的话，将其余部分都转换为UID，然后拼在一起，就可以组成为TSUID。</p>
<p><strong>Metadata</strong></p>
<p>主要用于记录data point的一些附加的信息，方便搜索和跟踪，分为UIDMeta和TSMeta。</p>
<p>每一个UID都有一个metadata记录保存在<code>tsdb-uid</code>表中，每一个UID包括一些不可变的字段，如<code>uid</code>、<code>type</code>、<code>name</code>和<code>created</code>字段表示什么时候被创建，还可以有一些额外字段，如<code>description</code>、<code>notes</code>、<code>displayName</code>和一些<code>custom</code> key/value对，详细信息，可以查看<a target="_blank" rel="noopener" href="http://opentsdb.net/docs/build/html/api_http/uid/uidmeta.html"> /api/uid/uidmeta</a></p>
<p>同样，每一个TSUID可以对应一个TSMeta，记录在<code>tsdb-uid</code>中，其包括的字段有<code>tsuid</code>、<code>metric</code>、<code>tags</code>、<code>lastReceived</code>和<code>created</code>，可选的字段有<code>description</code>, <code>notes</code>，详细信息，可以查看<a target="_blank" rel="noopener" href="http://opentsdb.net/docs/build/html/api_http/uid/tsmeta.html">/api/uid/tsmeta</a></p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>OpenTSDB的架构图如下所示：</p>
<ol>
<li>Servers是采集层，部署了OpenTSDB的采集agent。</li>
<li>TSD是OpenTSDB的核心模块，OpenTSDB是由一系列TSD（Time Series Daemon）组成。每个TSD都是独立的，没有master，没有共享状态</li>
<li>HBase是OpenTSDB的底层存储模块</li>
</ol>
<p>TSD对外提供三种交互接口：</p>
<ol>
<li>类似telnet的协议</li>
<li>HTTP API</li>
<li>内置的GUI</li>
</ol>
<img src="/2021/02/07/OpenTSDB%E5%85%A5%E9%97%A8/tsdb-architecture.png" class="" title="OpenTSDB architecture">

<p>OpenTSDB在HBase里共创建了4张表：</p>
<ol>
<li><p>UID_TABLE</p>
<ol>
<li><p>用来存储UID映射，包括正向的和反向的。存在两列族，一列族叫做name用来将一个UID映射到一个字符串，另一个列族叫做id，用来将字符串映射到UID。列族的每一行都至少有以下三列中的一个：</p>
<ul>
<li>metrics 将metric的名称映射到UID</li>
<li>tagk 将tag名称映射到UID</li>
<li>tagv 将tag的值映射到UID</li>
</ul>
<p>如果配置了metadata，则name列族还可以包括额外的metatata列。</p>
</li>
</ol>
</li>
<li><p>TSDB_TABLE</p>
<ol>
<li>时间点数据就保存在此表中，只有一个列簇t</li>
</ol>
</li>
<li><p>TREE_TABLE</p>
<ol>
<li>索引表，用于展示树状结构的，类似文件系统，以方便其他系统使用</li>
</ol>
</li>
<li><p>META_TABLE</p>
<ol>
<li>是不同时间序列的一个索引，可以用来存储一些额外的信息，该表只有一个列族name，两个列，分别为ts_meta、ts_ctr。这个表里面的数据是可以根据配置项配置来控制是否生成与否，生成几个列。</li>
</ol>
</li>
</ol>
<h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><blockquote>
<p>摘自参考4</p>
</blockquote>
<p>在解析OpenTSDB的表结构设计前，我们需要先对其底层的HBase的存储模型有一个理解。</p>
<h2 id="表分区"><a href="#表分区" class="headerlink" title="表分区"></a>表分区</h2><p>HBase会按Rowkey的范围，将一张大表切成多个region，每个region会由一个region server加载并提供服务。Rowkey的切分与表格存储的分区类似，一个良好设计的表，需要保证读写压力能够均匀的分散到表的各个region，这样才能充分发挥分布式集群的能力。</p>
<h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><img src="/2021/02/07/OpenTSDB%E5%85%A5%E9%97%A8/05224f4c4a40c93dcddc983a7a717ff7a047de50.png" class="" title="05224f4c4a40c93dcddc983a7a717ff7a047de50">

<p>如图所示为表结构以及对应的存储结构示例，在HBase或表格存储这类底层采用LSM-tree的数据库中，表数据会按列存储。每行中的每一列在存储文件中都会以Key-value的形式存在于文件中。其中Key的结构为：行主键 + 列名，Value为列的值。该种存储结构的特点是：</p>
<p>​    a. 每行主键会重复存储，取决于列的个数</p>
<p>​    b. 列名会重复存储，每一列的存储都会携带列名</p>
<p>​    c. 存储数据按row-key排序，相邻的row-key会存储在相邻的块中</p>
<h2 id="OpenTSDB的基本概念"><a href="#OpenTSDB的基本概念" class="headerlink" title="OpenTSDB的基本概念"></a>OpenTSDB的基本概念</h2><p>OpenTSDB定义每个时间序列数据需要包含以下属性：</p>
<ol>
<li><p>指标名称（metric name）</p>
</li>
<li><p>时间戳（UNIX timestamp，毫秒或者秒精度）</p>
</li>
<li><p>值（64位整数或者单精度浮点数）</p>
</li>
<li><p>一组标签（tags，用于描述数据属性，至少包含一个或多个标签，每个标签由tagKey和tagValue组成，tagKey和tagValue均为字符串）</p>
</li>
</ol>
<p>举个例子，在监控场景中，我们可以这样定义一个监控指标：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">指标名称：</span><br><span class="line">    sys.cpu.user</span><br><span class="line">标签：</span><br><span class="line">    host = <span class="number">10.101</span><span class="number">.168</span><span class="number">.111</span></span><br><span class="line">    cpu = <span class="number">0</span></span><br><span class="line">指标值：</span><br><span class="line">    <span class="number">0.5</span></span><br></pre></td></tr></table></figure>
<p>指标名称代表这个监控指标是对用户态CPU的使用监控，引入了两个标签，分别标识该监控位于哪台机器的哪个核。</p>
<p>OpenTSDB支持的查询场景为：指定指标名称和时间范围，给定一个或多个标签名称和标签的值作为条件，查询出所有的数据。</p>
<p>以上面那个例子举例，我们可以查询：</p>
<p>  a. sys.cpu.user (host=<em>,cpu=</em>)(1465920000 &lt;= timestamp &lt; 1465923600)：查询凌晨0点到1点之间，所有机器的所有CPU核上的用户态CPU消耗。</p>
<p>  b. sys.cpu.user (host=10.101.168.111,cpu=*)(1465920000 &lt;= timestamp &lt; 1465923600)：查询凌晨0点到1点之间，某台机器的所有CPU核上的用户态CPU消耗。</p>
<p>  c. sys.cpu.user (host=10.101.168.111,cpu=0)(1465920000 &lt;= timestamp &lt; 1465923600)：查询凌晨0点到1点之间，某台机器的第0个CPU核上的用户态CPU消耗。</p>
<h2 id="OpenTSDB的存储优化"><a href="#OpenTSDB的存储优化" class="headerlink" title="OpenTSDB的存储优化"></a>OpenTSDB的存储优化</h2><p>了解了OpenTSDB的基本概念后，我们来尝试设计一下表结构。</p>
<img src="/2021/02/07/OpenTSDB%E5%85%A5%E9%97%A8/f77d814e298bca40cdefcea04892fe702ba232c7.png" class="" title="f77d814e298bca40cdefcea04892fe702ba232c7">

<p>如上图是一个简单的表结构设计，rowkey采用metric name + timestamp + tags的组合，因为这几个元素才能唯一确定一个指标值。</p>
<p>这张表已经能满足我们的写入和查询的业务需求，但是OpenTSDB采用的表结构设计远没有这么简单，我们接下来一项一项看它对表结构做的一些优化。</p>
<h3 id="优化一：缩短row-key"><a href="#优化一：缩短row-key" class="headerlink" title="优化一：缩短row key"></a>优化一：缩短row key</h3><p>观察这张表内存储的数据，在rowkey的组成部分内，其实有很大一部分的重复数据，重复的指标名称，重复的标签。以上图为例，如果每秒采集一次监控指标，cpu为2核，host规模为100台，则一天时间内sys.cpu.user这个监控指标就会产生17280000行数据，而这些行中，监控指标名称均是重复的。如果能将这部分重复数据的长度尽可能的缩短，则能带来非常大的存储空间的节省。</p>
<p>OpenTSDB采用的策略是，为每个metric、tag key和tag value都分配一个UID，UID为固定长度三个字节。</p>
<img src="/2021/02/07/OpenTSDB%E5%85%A5%E9%97%A8/e1e766e7defcf059535c9c184a0659b499221c38.png" class="" title="e1e766e7defcf059535c9c184a0659b499221c38">

<p>上图为优化后的存储结构，可以看出，rowkey的长度大大的缩短了。rowkey的缩短，带来了很多好处：</p>
<p>  a. 节省存储空间</p>
<p>  b. 提高查询效率：减少key匹配查找的时间</p>
<p>  c. 提高传输效率：不光节省了从文件系统读取的带宽，也节省了数据返回占用的带宽，提高了数据写入和读取的速度。</p>
<p>  d. 缓解Java程序内存压力：Java程序，GC是老大难的问题，能节省内存的地方尽量节省。原先用String存储的metric name、tag key或tag value，现在均可以用3个字节的byte array替换，大大节省了内存占用。</p>
<h3 id="优化二：减少Key-Value数"><a href="#优化二：减少Key-Value数" class="headerlink" title="优化二：减少Key-Value数"></a>优化二：减少Key-Value数</h3><p>优化一是OpenTSDB做的最核心的一个优化，很直观的可以看到存储的数据量被大大的节省了。原理也很简单，将长的变短。但是是否还可以进一步优化呢？</p>
<p>在上面的存储模型章节中，我们了解到。HBase在底层存储结构中，每一列都会以Key-Value的形式存储，每一列都会包含一个rowkey。如果要进一步缩短存储量，那就得想办法减少Key-Value的个数。</p>
<p>OpenTSDB分了几个步骤来减少Key-Value的个数：</p>
<ol>
<li><p>将多行合并为一行，多行单列变为单行多列。</p>
</li>
<li><p>将多列合并为一列，单行多列变为单行单列。</p>
</li>
</ol>
<h4 id="多行单列合并为单行单列"><a href="#多行单列合并为单行单列" class="headerlink" title="多行单列合并为单行单列"></a>多行单列合并为单行单列</h4><img src="/2021/02/07/OpenTSDB%E5%85%A5%E9%97%A8/6106c668b7104312859391a26994029372a8f9de.png" class="" title="6106c668b7104312859391a26994029372a8f9de">

<p>OpenTSDB将同属于一个时间周期内的具有相同TSUID（相同的metric name，以及相同的tags）的数据合并为一行存储。OpenTSDB内默认的时间周期是一个小时，也就是说同属于这一个小时的所有数据点，会合并到一行内存储，如图上所示。合并为一行后，该行的rowkey中的timestamp会指定为该小时的起始时间（所属时间周期的base时间），而每一列的列名，则记录真实数据点的时间戳与该时间周期起始时间（base）的差值。</p>
<p>这里列名采用差值而不是真实值也是一个有特殊考虑的设计，如存储模型章节所述，列名也是会存在于每个Key-Value中，占用一定的存储空间。如果是秒精度的时间戳，需要4个字节，如果是毫秒精度的时间戳，则需要8个字节。但是如果列名只存差值且时间周期为一个小时的话，则如果是秒精度，则差值取值范围是0-3600，只需要2个字节；如果是毫秒精度，则差值取值范围是0-360000，只需要4个字节；所以相比存真实时间戳，这个设计是能节省不少空间的。</p>
<h4 id="单行多列合并为单行单列"><a href="#单行多列合并为单行单列" class="headerlink" title="单行多列合并为单行单列"></a>单行多列合并为单行单列</h4><p>多行合并为单行后，并不能真实的减少Key-Value个数，因为总的列数并没有减少。所以要达到真实的节省存储的目的，还需要将一行的列变少，才能真正的将Key-Value数变少。</p>
<p>OpenTSDB采取的做法是，会在后台定期的将一行的多列合并为一列，称之为『compaction』，合并完之后效果如下。</p>
<img src="/2021/02/07/OpenTSDB%E5%85%A5%E9%97%A8/e85374ccb1823e8829afc5407d32ea14ae2a9078.png" class="" title="e85374ccb1823e8829afc5407d32ea14ae2a9078">

<p>同一行中的所有列被合并为一列，如果是秒精度的数据，则一行中的3600列会合并为1列，Key-Value数从3600个降低到只有1个。</p>
<h3 id="优化三：并发写优化"><a href="#优化三：并发写优化" class="headerlink" title="优化三：并发写优化"></a>优化三：并发写优化</h3><p>上面两个优化主要是OpenTSDB对存储的优化，存储量下降以及Key-Value个数下降后，除了直观的存储量上的缩减，对读和写的效率都是有一定提升的。</p>
<p>时间序列数据的写入，有一个不可规避的问题是写热点问题，当某一个metric下数据点很多时，则该metric很容易造成写入热点。OpenTSDB采取了和这篇<a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/54644">文章</a>中介绍的一样的方法，允许将metric预分桶，可通过『<strong>tsd.storage.salt.buckets</strong>』配置项来配置。</p>
<img src="/2021/02/07/OpenTSDB%E5%85%A5%E9%97%A8/7fab2b13b9c2e05508de947ca887962f211fc351.png" class="" title="7fab2b13b9c2e05508de947ca887962f211fc351">

<p>如上图所示，预分桶后的变化就是在rowkey前会拼上一个桶编号（bucket index）。预分桶后，可将某个热点metric的写压力分散到多个桶中，避免了写热点的产生。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>OpenTSDB属于第二代时序数据库了，基于通用存储系统而发展来的。获得了通用存储系统的扩展性，高可用特性，但是因为无法做一些针对时序数据的特定优化，会有一些限制。例如数据压缩针对性优化，查询针对性的优化。</p>
<p>具有以下缺点：</p>
<ol>
<li><p><strong>数据类型单一</strong>：HBase中数据都是字符串，没有其他类型</p>
</li>
<li><p><strong>压缩效果差</strong>：数据冗余大，压缩效果一般</p>
</li>
<li><p><strong>自身不支持复杂条件过滤</strong>：监控场景里，存在大量过滤条件，都只能在业务逻辑里实现，构成rowkey后查询，不能直接由hbase处理好，返回给应用；因此数据都是预聚合的。</p>
</li>
<li><p><strong>部署和运维难度大</strong>：依赖于zookeeper，比较重，需要专业的人员进行运维。</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a target="_blank" rel="noopener" href="http://opentsdb.net/overview.html">OpenTSDB官网</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://medium.com/analytics-vidhya/understanding-opentsdb-a-distributed-and-scalable-time-series-database-e4efc7a3dbb7">Understanding OpenTSDB — A distributed and scalable Time Series Database</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/25847">All Things OpenTSDB</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/54785">解密OpenTSDB的表存储优化</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fea98d05ec04">NoSQL-Hbase-Hbase作为OpenTSDB的优缺点分析</a></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/07/RRD-Graphite%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/07/RRD-Graphite%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">RRD-Graphite时序数据库简述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-02-07 15:01:32 / 修改时间：17:09:41" itemprop="dateCreated datePublished" datetime="2021-02-07T15:01:32+08:00">2021-02-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RDD简介"><a href="#RDD简介" class="headerlink" title="RDD简介"></a>RDD简介</h1><p>RRD （Round Robin Database）数据库是一个环形的数据库，你可以把它想象成圆盘，中心处有一个指针，随着时间的变化，指针也在变，当指针指到 12 点处，也就是这个记录要被擦除覆盖的时刻。因为它是圆形的，无始无终，可以一直往里写数据，只是历史数据会被覆盖掉，所以，有时它又被叫做时序结构数据库。</p>
<p>RRD诞生于1999年，前身是MRTG，MRTG主要用来自动采集系统的一些统计指标并进行绘图，实现对系统的监控。RRD主要是为了解决MRTG的一些问题而诞生的，主要面向的也是监控场景数据。</p>
<p>虽然通用关系数据库可以存储时序数据，但是由于缺乏针对时间的特殊优化，比如按时间间隔存储和检索数据等等，因此在处理这些数据时效率相对不高。</p>
<p>RRD属于第一代时序数据库，数据也典型来源于监控领域，直接基于平板文件的简单存储工具成为这类数据的首先存储方式。</p>
<img src="/2021/02/07/RRD-Graphite%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E8%BF%B0/rrd%E7%8E%AF%E5%BD%A2%E7%BB%93%E6%9E%84.jpg" class="" title="rrd环形结构">

<h2 id="RRDTool"><a href="#RRDTool" class="headerlink" title="RRDTool"></a>RRDTool</h2><p>RRDTool是RRD数据库配套的一个工具，它可以安装在Unix或者Windows系统上，RRDTool提供了一系列的命令集来对RRD进行不同的操作。</p>
<p>RRDTool既是后端工具，又是前端工具；之所以这么说，是因为作为数据库，首先RRDTool可以存储数据，此外，RRDTool也提供了一个根据数据库数据进行绘图的功能，这让它具备了前端的特性。</p>
<h2 id="基本使用语法"><a href="#基本使用语法" class="headerlink" title="基本使用语法"></a>基本使用语法</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rrdtool create filename  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 建一个名为 filename 的数据库文件，通常 RRD 数据库文件的后缀为 .rrd ，但是你随便使用文件名也不会有影响</span></span><br><span class="line">[--start|-b start time]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个选项表示 RRD 数据库的起始 (start/begin) 时间点为 start-time，这是一个从 1970-01-01 00:00:00 开始计时，以秒为间隔的一个整数值。</span></span><br><span class="line">[--step|-s step]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个选项表示监测的时间间隔，即多久时间去获取一次被监测对象的数值，默认值为5分钟(300秒)。</span></span><br><span class="line">[--template|-t template-file]</span><br><span class="line">[--source|-r source-file] </span><br><span class="line">[--no-overwrite|-O] </span><br><span class="line">[--daemon|-d address] </span><br><span class="line">[DS:ds-name[=mapped-ds-name[[source-index]]]:DST:dst arguments] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个选项用来定义数据源(Data Source)属性，包括数据源名称 ds-name，比如我们可以给监测内存使用率的数据源命名为 memory-rate。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> DST(Data Source Type)数据源类型</span></span><br><span class="line">[RRA:CF:cf arguments]</span><br><span class="line"><span class="meta">#</span><span class="bash"> RRA (Round Robin Archive) 是用来定义 RRD 数据库归档模型，RRDTool 绘图展示监测情况的时候就从 RRA 中获取数据。CF (Consolidation Function)是用来处理原始数据的函数</span></span><br></pre></td></tr></table></figure>


<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="DST"><a href="#DST" class="headerlink" title="DST"></a>DST</h5><p>DST七种类型：</p>
<ol>
<li>GAUGE<ol>
<li>实测值</li>
</ol>
</li>
<li>COUNTER<ol>
<li>计数器，只增不减，RRD收到值后，会计算变化率，而不是存储原始值</li>
</ol>
</li>
<li>DCOUNTER<ol>
<li>也是计数器，但是是double类型的，并且可以递减或递增</li>
</ol>
</li>
<li>DERIVE<ol>
<li>存储的也是变化率，和 COUNTER 类型不同的是，监测值可以增长也可以下降</li>
</ol>
</li>
<li>DDERIVE<ol>
<li>也是计数器，但是是double类型的，并且可以递减或递增</li>
</ol>
</li>
<li>ABSOLUTE<ol>
<li>类似counter，存储的也是变化率，但是每次读取时会重置counter为0</li>
</ol>
</li>
<li>COMPUTE<ol>
<li>对测量值进行计算后的值</li>
</ol>
</li>
</ol>
<h5 id="CF"><a href="#CF" class="headerlink" title="CF"></a>CF</h5><p>也有几种函数；</p>
<ol>
<li>AVERAGE</li>
<li>MIN</li>
<li>MAX</li>
<li>LAST</li>
</ol>
<h5 id="数据点类型"><a href="#数据点类型" class="headerlink" title="数据点类型"></a>数据点类型</h5><p>RAR（round robin archives）数据存储格式，包含很多CDP。我们可以把一个RRA 看成一个表，各保存不同 interval 的统计结果。RRA的作用就是定义更新的数据是如何记录的。</p>
<p>PDP (Primary Data Point) 原始数据点</p>
<p>CDP (Consolidation Data Point) 归档数据点</p>
<p>一个 CDP 由多个 PDP 经过归档函数计算得到。</p>
<p>如下图所示：</p>
<img src="/2021/02/07/RRD-Graphite%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E8%BF%B0/rrd-cdp-pdp.jpg" class="" title="rrd-cdp-pdp">

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>实际上是插入数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rrdtool &#123;update | updatev&#125; filename</span><br><span class="line">[--template|-t ds-name[:ds-name]...] </span><br><span class="line">[--skip-past-updates|-s] </span><br><span class="line">[--daemon|-d address]</span><br><span class="line">[--] N:value[:value]... timestamp:value[:value]... at-timestamp@value[:value]...</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rrdtool fetch filename CF </span><br><span class="line">[--resolution|-r resolution] </span><br><span class="line">[--start|-s start] </span><br><span class="line">[--end|-e end] </span><br><span class="line">[--align-start|-a] </span><br><span class="line">[--daemon|-d address]</span><br></pre></td></tr></table></figure>
<p>CF只支持四种：</p>
<ol>
<li>AVERAGE</li>
<li>MIN</li>
<li>MAX</li>
<li>LAST</li>
</ol>
<h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><p>根据RRD数据库中的数据绘制图形，生成图片。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rrdtool graph|graphv filename </span><br><span class="line">[option ...] </span><br><span class="line">[data definition ...] </span><br><span class="line">[data calculation ...] </span><br><span class="line">[variable definition ...]</span><br><span class="line">[graph element ...]</span><br><span class="line">[print element ...]</span><br></pre></td></tr></table></figure>


<h1 id="Graphite简介"><a href="#Graphite简介" class="headerlink" title="Graphite简介"></a>Graphite简介</h1><p>Graphite是一种企业级监控工具，在廉价的硬件或云基础设施上同样运行良好。团队使用Graphite来跟踪他们的网站、应用程序、业务服务和网络服务器的性能。它标志着新一代监控工具的开始，使得存储、检索、共享和可视化时间序列数据比以往任何时候都更容易。</p>
<p>Graphite是一个开源实时的、显示时间序列度量数据的图形系统。Graphite并不收集度量数据本身，而是像一个数据库，通过其后端接收度量数据，然后以实时方式查询、转换、组合这些度量数据。Graphite支持内建的Web界面，它允许用户浏览度量数据和图。</p>
<p>Graphite有三个主要组件组成：</p>
<ul>
<li>1）Graphite-Web<br>这是一个基于Django的Web应用，可以呈现图形和仪表板，图形库基于Cairo</li>
<li>2）Carbon<br>这是基于Twisted的守护进程，用于接收时序数据</li>
<li>3）Whisper<br>这是一个时序数据库，类似RRD</li>
</ul>
<img src="/2021/02/07/RRD-Graphite%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E8%BF%B0/architecture_diagram.png" class="" title="architecture_diagram">

<h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><h3 id="Carbon"><a href="#Carbon" class="headerlink" title="Carbon"></a>Carbon</h3><p>数据接收模块。</p>
<h4 id="carbon-relay"><a href="#carbon-relay" class="headerlink" title="carbon-relay"></a>carbon-relay</h4><p>有两种不同的用途：</p>
<ol>
<li>将指标复制</li>
<li>对指标分区</li>
</ol>
<p>当配置为复制时，relay可以把指标发给多个carbon-cache实例进行复制；当配置为分区时，relay会使用一个分区策略把指标发给多个carbon-cache实例。</p>
<h4 id="carbon-aggregator"><a href="#carbon-aggregator" class="headerlink" title="carbon-aggregator"></a>carbon-aggregator</h4><p>可以放到carbon-cache前面，在将度量报告到whisper之前，将度量缓冲一段时间。这在不需要细粒度报告时非常有用，而且由于保留数据少，因此有助于减少I/O负载和文件大小。目前只支持avg和sum两种函数对数据进行聚合计算。</p>
<h4 id="carbon-cache"><a href="#carbon-cache" class="headerlink" title="carbon-cache"></a>carbon-cache</h4><p>接受通过各种协议传输来的指标项数据并以尽可能高的效率将它们写入磁盘；在接收到指标项时，将指标项值缓存在 RAM 中，并用底层的 Whisper 库按照指定的时间间隔将这些值写入磁盘。</p>
<h3 id="Whisper"><a href="#Whisper" class="headerlink" title="Whisper"></a>Whisper</h3><p>Whisper是一个固定大小的数据库，在设计和用途上与RRD（循环数据库）相似。随着时间的推移，它提供了快速、可靠的数字数据存储。Whisper允许最近数据的更高分辨率（每点秒数）降级为较低分辨率，以便长期保留历史数据。</p>
<h4 id="归档：保留周期和精度"><a href="#归档：保留周期和精度" class="headerlink" title="归档：保留周期和精度"></a>归档：保留周期和精度</h4><p>Whisper数据库包含一个或多个存档（存储区），每个存档都具有特定的数据精度和保留周期（以点数或最大时间戳期限定义）。归档文件的顺序是从最高分辨率和最短保留期归档文件到最低分辨率和最长保留期归档文件。</p>
<p>为了支持从高分辨率存档到低分辨率存档的精确聚合，较长保留期存档的精度必须可以除以下一个较低保留期存档的精度。例如，每60秒有一个数据点的归档文件后面可以有一个分辨率较低的归档文件，其分辨率为每300秒有一个数据点，因为300能被60整除。相比之下，180秒的精度（3分钟）不能跟在600秒的精度（10分钟）之后，因为从第一个存档传播到下一个存档的点的比率是10/3，而Whisper不会进行部分点插值。</p>
<p>数据库的总保留时间由保留时间最高的存档决定，因为每个存档所覆盖的时间段是重叠的（请参见多存档存储和检索行为）。也就是说，一对保留期为1个月和1年的档案将无法提供13个月的数据存储时间。相反，它将提供1年的存储时间，相当于它最长的存档时间。</p>
<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><ul>
<li>average</li>
<li>sum</li>
<li>last</li>
<li>max</li>
<li>min</li>
</ul>
<h4 id="多存档存储和检索行为"><a href="#多存档存储和检索行为" class="headerlink" title="多存档存储和检索行为"></a>多存档存储和检索行为</h4><p>当Whisper写入包含多个存档的数据库时，传入的数据点会同时写入所有存档。数据点将按原样写入最高分辨率的归档文件，并通过配置的聚合方法进行聚合，然后放入每个较高保留期的归档文件中。如果您需要最高分辨率点的聚合，请考虑使用carbon-aggregator。</p>
<p>在检索数据时（按时间范围），将使用第一个可以满足整个时间段的存档。如果时间段与存档边界重叠，将使用低分辨率存档。这允许在检索数据时执行更简单的行为，因为数据的分辨率在整个返回序列中是一致的。</p>
<h4 id="跟RRD对比"><a href="#跟RRD对比" class="headerlink" title="跟RRD对比"></a>跟RRD对比</h4><h5 id="RRD不能在最新更新之前对某个时隙进行更新"><a href="#RRD不能在最新更新之前对某个时隙进行更新" class="headerlink" title="RRD不能在最新更新之前对某个时隙进行更新"></a>RRD不能在最新更新之前对某个时隙进行更新</h5><p>这意味着没有办法在RRD序列中回填数据。Whisper没有这个限制，这使得将历史数据导入Graphite变得更加简单和容易</p>
<h5 id="RRD的设计没有考虑到不定期的更新"><a href="#RRD的设计没有考虑到不定期的更新" class="headerlink" title="RRD的设计没有考虑到不定期的更新"></a>RRD的设计没有考虑到不定期的更新</h5><p>在许多情况下（取决于配置），如果对RRD时序进行了更新，但没有很快进行另一次更新，则原始更新将丢失。这使得它不太适合记录数据，例如操作度量（例如代码推送）</p>
<h5 id="Whisper要求度量更新与最佳分辨率存储存档的间隔相同"><a href="#Whisper要求度量更新与最佳分辨率存储存档的间隔相同" class="headerlink" title="Whisper要求度量更新与最佳分辨率存储存档的间隔相同"></a>Whisper要求度量更新与最佳分辨率存储存档的间隔相同</h5><p>这就将聚合值的责任推给了用户，而不是数据库。这也意味着更新会立即写入到最精确的存档中，而不是像在RRD中那样先进行聚合，然后再写入（在随后的写入操作中）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RRD和Graphite属于第一代时序数据库，存储结构简单，均是一个环缓存的结构，功能支持也有限，但是目前使用还是比较广泛的。了解它们的设计，也能了解下时序数据库的特点和发展历史。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/54400">RRDTool原理简介</a></li>
<li><a target="_blank" rel="noopener" href="http://bbs.chinaunix.net/thread-864861-1-1.html">RRDtool简体中文教程 v1.01</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/711500">浅谈时序数据库那些事</a></li>
<li><a target="_blank" rel="noopener" href="https://oss.oetiker.ch/rrdtool/doc/index.en.html">RRDtool Documentation</a></li>
<li><a target="_blank" rel="noopener" href="http://graphiteapp.org/">graphite官网</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/graphite-intro/">DevOps 实战：Graphite 监控上手指南</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/29/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/29/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-01-29 17:13:28 / 修改时间：13:55:37" itemprop="dateCreated datePublished" datetime="2021-01-29T17:13:28+08:00">2021-01-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason Chao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
