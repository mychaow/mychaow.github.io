<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="我住8楼">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="我住8楼">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason Chao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>我住8楼</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我住8楼</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason Chao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/29/tsfile%E5%89%96%E6%9E%90-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/29/tsfile%E5%89%96%E6%9E%90-1/" class="post-title-link" itemprop="url">tsfile剖析-1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-01-29 16:55:58 / 修改时间：16:57:39" itemprop="dateCreated datePublished" datetime="2021-01-29T16:55:58+08:00">2021-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tsdb/" itemprop="url" rel="index"><span itemprop="name">tsdb</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><h1 id="初步想法"><a href="#初步想法" class="headerlink" title="初步想法"></a>初步想法</h1><h1 id="问题和演化"><a href="#问题和演化" class="headerlink" title="问题和演化"></a>问题和演化</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/" class="post-title-link" itemprop="url">程序员的自我修养读书笔记-2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-01-29 15:19:24 / 修改时间：15:19:40" itemprop="dateCreated datePublished" datetime="2021-01-29T15:19:24+08:00">2021-01-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.c</span><br><span class="line"></span><br><span class="line">extern int shared;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a &#x3D; 100;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.c </span><br><span class="line"></span><br><span class="line">int shared &#x3D; 1;</span><br><span class="line"></span><br><span class="line">void swap (int* a, int* b) &#123;</span><br><span class="line">    *a ^&#x3D; *b ^&#x3D; *a ^&#x3D; *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h2><p>多个不同目标文件链接到一起，多个段怎么拼接到一起：</p>
<ol>
<li>按序叠加：将输入的目标文件按照次序叠加起来，会导致输出文件中很多零散的段，段对齐后还会导致大量的内部碎片</li>
<li>相似段合并：将相同性质的段合并到一起</li>
</ol>
<p>现在链接器一般采用第二种方法，这种链接器一般都采用一种叫两步链接的方法。</p>
<ol>
<li>空间与地址分配：合并所有段，并搜集所有符号放到一个全局符号表</li>
<li>符号解析与重定位：符号解析与重定位、调整代码中的地址</li>
</ol>
<h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><p>链接器通过elf文件中的重定位表来获得需要被重定位的符号信息，然后根据不同符号类型，比如变量和函数，来决定使用地址修正方式。<br>x86架构上重定位有两种类型：</p>
<table>
<thead>
<tr>
<th align="left">宏定义</th>
<th align="left">值</th>
<th align="left">重定位修正方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R_386_32</td>
<td align="left">1</td>
<td align="left">绝对寻址修正 S + A</td>
</tr>
<tr>
<td align="left">R_386_PC32</td>
<td align="left">2</td>
<td align="left">相对寻址修正 S + A - P</td>
</tr>
</tbody></table>
<p>A = 保存在被修正位置的值<br>P = 被修正的位置（相对于段开始的偏移量或者虚拟地址）<br>S = 符号的实际地址</p>
<h2 id="common块"><a href="#common块" class="headerlink" title="common块"></a>common块</h2><p>解决多个符号定义的问题，将多个弱符号定义到一个共享地址中，以空间最大的为最终结果。</p>
<h2 id="c-相关问题"><a href="#c-相关问题" class="headerlink" title="c++相关问题"></a>c++相关问题</h2><ol>
<li><p>重复代码消除</p>
<ol>
<li>模板实例化被编译到一个段，这样多个编译单元可以共享</li>
<li>虚函数，放到虚函数表中，多个实例共享该函数表</li>
<li>外部内联函数、默认构造函数、默认拷贝构造函数和赋值操作符等都是类似处理</li>
<li>函数级别链接，库中的函数都单独放到一个段里，这样只用链接需要用的函数，减少空间浪费</li>
</ol>
</li>
<li><p>全局构造与析构</p>
<ol>
<li>linux系统的程序入口是_start,程序初始化完成一系列初始化过程之后，会调用main函数来执行程序主体</li>
<li>elf文件中的两个段.init和.fini是main函数执行之前和结束后调用，构造和析构函数一般放在这两个段中实现</li>
</ol>
</li>
<li><p>ABI</p>
<p>二进制层面的接口，影响因素非常多，例如：</p>
<ol>
<li>内置类型</li>
<li>组合类型</li>
<li>外部符号</li>
<li>函数调用方式</li>
<li>堆栈的分布式方式</li>
<li>寄存器使用约定</li>
<li>…<br>c++的语法太复杂，其对ABI的影响非常多，因此二进制兼容性一直不好，除了不同编译器二进制代码之间无法相互兼容，还有编译器不同版本也不兼容。</li>
</ol>
</li>
</ol>
<h2 id="静态库链接"><a href="#静态库链接" class="headerlink" title="静态库链接"></a>静态库链接</h2><p>一组目标文件的集合，linux下是libc.a, 由ar压缩程序将各个不同函数目标文件压缩而成。</p>
<h2 id="链接过程控制"><a href="#链接过程控制" class="headerlink" title="链接过程控制"></a>链接过程控制</h2><p>链接器提供多种方式控制链接过程：</p>
<ol>
<li>命令行给链接器指定参数</li>
<li>将链接指令放到目标文件中</li>
<li>使用链接控制脚本</li>
</ol>
<h2 id="BFD库"><a href="#BFD库" class="headerlink" title="BFD库"></a>BFD库</h2><p>抽象一种统一的接口来处理不同的目标文件格式，它把目标文件抽象成一个统一的模型，现在GCC都是通过BFD库来处理目标文件。如果需要支持新的目标文件格式，只需在BFD中添加一种格式就行。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章主要是介绍了静态链接的第一个步骤，主要是各个目标文件的合并以及重定位。还介绍了一些静态链接过程中的几个典型问题：common块处理弱符号，链接脚本控制链接过程来定制化某些特殊需求等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/" class="post-title-link" itemprop="url">程序员的自我修养读书笔记-1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-01-29 15:18:28 / 修改时间：16:26:06" itemprop="dateCreated datePublished" datetime="2021-01-29T15:18:28+08:00">2021-01-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="温故而知新"><a href="#温故而知新" class="headerlink" title="温故而知新"></a>温故而知新</h1><h2 id="硬件和操作系统历史"><a href="#硬件和操作系统历史" class="headerlink" title="硬件和操作系统历史"></a>硬件和操作系统历史</h2><h3 id="计算机硬件历史"><a href="#计算机硬件历史" class="headerlink" title="计算机硬件历史"></a>计算机硬件历史</h3><p>计算机中最重要的是三个部件：cpu，内存，io控制芯片<br>历史：</p>
<ol>
<li>早期cpu和内存以及io控制器是链接在一条总线上的</li>
<li>后来cpu频率上升，并且图形芯片与内存和cpu交互变多，设计北桥芯片处理这种高速数据交互；对于低速的io设备，设计南桥来总领慢速io设备与北桥通信</li>
<li>单核cpu频率到瓶颈，转向多核架构；最常见的就是SMP(对称多处理器),多个处理器对等，通过总线通信。（多核处理器是SMP的简化版，它将多个核心打包，共享昂贵的缓存组件以单个处理器的方式售卖)</li>
</ol>
<h3 id="操作系统历史"><a href="#操作系统历史" class="headerlink" title="操作系统历史"></a>操作系统历史</h3><p>操作系统两个功能：</p>
<ol>
<li>提供一个抽象的接口</li>
<li>管理硬件资源</li>
</ol>
<p>CPU资源利用历史：</p>
<ol>
<li>多道程序：可以多个程序流水线执行，不用一个程序等待上一个程序完全处理完成（比如程序最后是写磁盘，但是依然不让下一个程序开始用闲下来的CPU资源）</li>
<li>分时系统：每个程序运行一段时间，主动放弃cpu</li>
<li>多任务系统：操作系统接管所有硬件资源，各任务以进程方式运行，cpu轮流调度不同进程；如果cpu会强行打断任务执行，根据优先级将cpu资源分配给别的进程，那么这就是抢占式任务调度方式。</li>
</ol>
<p>设备驱动：</p>
<ol>
<li>面向硬件接口编程</li>
<li>统一抽象，交给硬件驱动程序来处理</li>
</ol>
<p>内存：</p>
<ol>
<li>直接操作硬件RAM<ol>
<li>地址空间不隔离</li>
<li>内存使用率低，整块连续内存不停换入换出</li>
<li>程序运行的地址不确定</li>
</ol>
</li>
<li>分段技术：整段内存空间映射到虚拟地址空间<ol>
<li>解决了第一和第三个问题，但是第二问题还没有解决，映射粒度太大，空间不够时，可能小粒度的空间和等于需要的空间，但是不连续，无法映射</li>
</ol>
</li>
<li>分页技术：将内存按页4K来划分，换入换出以页为单位，粒度小，利用效率高</li>
</ol>
<h2 id="现代操作系统CPU抽象-线程"><a href="#现代操作系统CPU抽象-线程" class="headerlink" title="现代操作系统CPU抽象-线程"></a>现代操作系统CPU抽象-线程</h2><ol>
<li>线程基础<ol>
<li>线程有自己的私有存储空间：局部变量，函数的参数，TLS（线程局部存储）数据</li>
<li>线程共享存储（进程所有）：全局变量，堆上的数据，函数里的静态变量，程序代码，打开的文件</li>
<li>状态：运行、就绪、等待</li>
</ol>
</li>
<li>线程安全<ol>
<li>同步与锁<ol>
<li>二元信号量：任意线程获取和释放</li>
<li>互斥量：哪个线程获取，哪个线程释放</li>
<li>临界区：仅限本进程，信号量和互斥量在任何进程都可见</li>
<li>读写锁：分独占和共享方式获取</li>
<li>条件变量：类似栅栏，等待和唤醒</li>
<li>可重入：并发安全的保障</li>
</ol>
</li>
</ol>
</li>
<li>线程模型<ol>
<li>一对一模型：一个用户线程对应一个内核线程</li>
<li>多对一模型：多个用户线程对应一个内核线程，用不线程切换由用户代码执行，如果一个用户线程阻塞，会阻塞所有其他同核的用户线程</li>
<li>多对多模型：多个用户线程对应多个内核线程，性能提升没有一对一高，资源利用率最高了</li>
</ol>
</li>
</ol>
<h1 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h1><h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><ol>
<li>预编译<ol>
<li>将#define删除，并展开所有宏定义</li>
<li>处理所有条件预编译命令</li>
<li>处理#include预编译命令，将被包含的文件插入到对应位置</li>
<li>删除注释</li>
<li>添加文件行号和文件名标识</li>
<li>保留所有#pragma命令</li>
</ol>
</li>
<li>编译<ol>
<li>词法分析，语法分析，语义分析，生成汇编文件</li>
</ol>
</li>
<li>汇编<ol>
<li>将汇编代码转变为机器可执行指令</li>
</ol>
</li>
<li>链接<ol>
<li>将最终程序所需的所有文件都链接起来</li>
</ol>
</li>
</ol>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><ol>
<li>词法分析<ol>
<li>执行类似有限状态机的算法来将字符序列分割成一系列的记号</li>
<li>将记号分类为：关键字，标识符，字面量（包含数字，字符串等），特殊符号（加减号之类的）</li>
</ol>
</li>
<li>语法分析<ol>
<li>采用上下文无关语法来生成语法树，节点是表达式</li>
</ol>
</li>
<li>语义分析<ol>
<li>静态语义分析<ol>
<li>声明与类型的匹配</li>
<li>类型的转换</li>
<li>将语法树的每个节点标识了类型</li>
</ol>
</li>
</ol>
</li>
<li>中间语言生成<ol>
<li>将语法树转换为三地址码（x = y op z）</li>
<li>中间语言将编译器分割成前端和后端，前端将源码翻译成机器无关的中间代码，后端将中间代码转换为机器代码</li>
</ol>
</li>
<li>目标代码生成与优化<ol>
<li>属于编译器后端，包括代码生成器和目标代码优化器</li>
</ol>
</li>
</ol>
<h2 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h2><p>就是各个目标文件链接起来拼成最终目标文件。</p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><ol>
<li>地址和空间分配</li>
<li>符号决议（符号绑定）<ol>
<li>当编译器遇到一个不是本模块定义的符号时，会假设该函数由其它模块定义，并生成一个链接器符号表条目，交由链接器处理。如果链接器在它的任何输入模块都没有找到该符号，会给出一个类似undefined reference to ‘xxx’的链接错误。而如果链接器在输入模块中找到了一个以上的外部符号定义，这个时候就需要链接器进行符号决议，链接器对多个外部符号定义可能并不报错甚至警告，而是按照它的规则去选择其中一个符号定义。</li>
</ol>
</li>
<li>重定位<ol>
<li>计算各个目标地址的过程叫重定位</li>
</ol>
</li>
</ol>
<h1 id="目标文件里有什么"><a href="#目标文件里有什么" class="headerlink" title="目标文件里有什么"></a>目标文件里有什么</h1><h2 id="目标文件中的组成成分"><a href="#目标文件中的组成成分" class="headerlink" title="目标文件中的组成成分"></a>目标文件中的组成成分</h2><ol>
<li>代码段.text</li>
<li>数据段.data</li>
<li>未初始化数据段.bss: 只是为未初始化的全局变量和局部静态变量预留位置而已</li>
<li>只读数据段.rodata</li>
<li>调试信息段.debug</li>
<li>编译器版本信息段.comment</li>
<li>动态链接信息段.dynamic</li>
<li>字符串表.strtab, 存放各种字符串</li>
<li>符号表.symtab</li>
<li>段名表.shstrtab</li>
<li>初始化和终结代码段.init/.fini</li>
<li>动态链接的跳转表和全局入口表.plt/.got</li>
</ol>
<h2 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|    ELF Header      |</span><br><span class="line">|     .text          |</span><br><span class="line">|     .data          |</span><br><span class="line">|     .bss           |</span><br><span class="line">|  other sections    |</span><br><span class="line">|section header table|</span><br><span class="line">|  string tables     |</span><br><span class="line">|  symbol tables     |</span><br><span class="line">|      ...           |</span><br></pre></td></tr></table></figure>
<h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p>包含ELF魔数、文件机器字节长度、数据存储个方式、版本、运行平台、ABI 版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度、段的数量。其结构及相关常数被定义在/usr/include/elf.h里。</p>
<p>其中elf魔数的前16个字节被ELF标准规定用来标识ELF文件的平台属性，比如字长、字节序、elf文件版本信息等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; simplesection.c </span><br><span class="line"></span><br><span class="line">int printf(const char* format, ...);</span><br><span class="line">int global_init_var &#x3D; 84;</span><br><span class="line">int global_uninit_var;</span><br><span class="line"></span><br><span class="line">void func1(int i) &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    static int static_var &#x3D; 85;</span><br><span class="line">    static int static_var2;</span><br><span class="line"></span><br><span class="line">    int a &#x3D; 1;</span><br><span class="line">    int b;</span><br><span class="line"></span><br><span class="line">    func1(static_var + static_var2 + a + b);</span><br><span class="line"></span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; $ readelf -h simplesection.o</span><br><span class="line"></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#39;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS&#x2F;ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          376 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 10</span><br></pre></td></tr></table></figure>


<h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>段表是保存elf文件中各种各样的段基本属性的结构。描述了elf的各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。编译器、链接器、装载器都是依靠段表来定位和访问各个段的属性的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $ readelf -S a.o</span><br><span class="line"></span><br><span class="line">There are 13 section headers, starting at offset 0x178:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000054  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  000006a0</span><br><span class="line">       0000000000000078  0000000000000018          11     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000094</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000009c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  0000009c</span><br><span class="line">       0000000000000004  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  000000a0</span><br><span class="line">       0000000000000012  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000b2</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  000000b8</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000718</span><br><span class="line">       0000000000000030  0000000000000018          11     8     8</span><br><span class="line">  [10] .shstrtab         STRTAB           0000000000000000  00000110</span><br><span class="line">       0000000000000061  0000000000000000           0     0     1</span><br><span class="line">  [11] .symtab           SYMTAB           0000000000000000  000004b8</span><br><span class="line">       0000000000000180  0000000000000018          12    11     8</span><br><span class="line">  [12] .strtab           STRTAB           0000000000000000  00000638</span><br><span class="line">       0000000000000066  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure>


<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>.rela.text段，重定位表，记录代码段和数据段对绝对地址的引用的位置。</p>
<h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>因为elf文件中用到了很多字符串，比如段名、变量名等，因为字符串的长度往往是不确定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。</p>
<p>字符串表.strtab,用来存放普通的字符串，比如符号名字； 段表字符串表.shstrtab用来保持段表中用到的字符串，最常见的就是段名。</p>
<h2 id="链接的接口-符号"><a href="#链接的接口-符号" class="headerlink" title="链接的接口-符号"></a>链接的接口-符号</h2><p>最值得关注的是全局符号，因为链接过程只关心全局符号的相互“粘合”，局部符号、段名、行号等都是次要的，它们对于其他的目标文件来说是不可见的，在链接过程中无关紧要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $ nm simplesection.o</span><br><span class="line"></span><br><span class="line">0000000000000000 T func1</span><br><span class="line">0000000000000000 D global_init_var</span><br><span class="line">0000000000000004 C global_uninit_var</span><br><span class="line">0000000000000021 T main</span><br><span class="line">                 U printf</span><br><span class="line">0000000000000004 d static_var.1731</span><br><span class="line">0000000000000000 b static_var2.1732</span><br></pre></td></tr></table></figure>


<h3 id="elf符号表结构"><a href="#elf符号表结构" class="headerlink" title="elf符号表结构"></a>elf符号表结构</h3><p>elf文件中的一个段，段名叫.symtab。包含符号的信息：符号名、符号值（地址或绝对值）、符号大小、符号类型（数据对象、函数、段等）和绑定信息（局部，全局，弱引用）、符号所在的段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $ readelf -s simplesection.o</span><br><span class="line"></span><br><span class="line">Symbol table &#39;.symtab&#39; contains 16 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS simplesection.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_var.1731</span><br><span class="line">     7: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 static_var2.1732</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line">    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">    11: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_init_var</span><br><span class="line">    12: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM global_uninit_var</span><br><span class="line">    13: 0000000000000000    33 FUNC    GLOBAL DEFAULT    1 func1</span><br><span class="line">    14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf</span><br><span class="line">    15: 0000000000000021    51 FUNC    GLOBAL DEFAULT    1 main</span><br></pre></td></tr></table></figure>


<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>链接器会定义很多特殊的符号，比如程序起始地址、结束地址等，可以在程序中使用它们。</p>
<h3 id="符号修饰与函数签名"><a href="#符号修饰与函数签名" class="headerlink" title="符号修饰与函数签名"></a>符号修饰与函数签名</h3><p>符号修饰是为了统一符号名，以免冲突。</p>
<p>C++符号修饰</p>
<ol>
<li>函数签名，包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息。用于识别不同的函数（比如重载的函数）。通常是用名称修饰的方式来做签名。</li>
<li>符号修饰也可以用来防止静态变量的名字冲突。</li>
</ol>
<h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>避免c++符号修饰导致不识别c函数</p>
<h3 id="弱符号与强符号"><a href="#弱符号与强符号" class="headerlink" title="弱符号与强符号"></a>弱符号与强符号</h3><p>强符号是函数和初始化了的全局变量；弱符号是未初始化的全局变量。<br>链接器处理强符号、弱符号的规则</p>
<ol>
<li>不允许强符号被多次定义</li>
<li>如果有一个强符号，多个弱符号，选择强符号</li>
<li>如果都是弱符号，选择占用空间最大的一个</li>
</ol>
<p>强引用和弱引用<br>对外部目标文件定义的符号在目标文件最终被链接时，如果找不到该符号的定义，报未定义错误，这种被称为强引用。如果有定义，则引用该定义，如果没有，也不报错，就是弱引用。</p>
<h2 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h2><p>elf采用一种称为DWARF（Debug with arbitrary record format）格式的调试信息格式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/29/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/29/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">stl源码剖析-序列式容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-01-29 15:17:08 / 修改时间：16:40:23" itemprop="dateCreated datePublished" datetime="2021-01-29T15:17:08+08:00">2021-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/stl/" itemprop="url" rel="index"><span itemprop="name">stl</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="容器按排列分类"><a href="#容器按排列分类" class="headerlink" title="容器按排列分类"></a>容器按排列分类</h1><table>
<thead>
<tr>
<th align="left">序列式容器</th>
<th align="left"></th>
<th align="left">关联式容器</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">array(build-in)</td>
<td align="left"></td>
<td align="left">RB-Tree</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">vector</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">set</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">heap</td>
<td align="left"></td>
<td align="left">map</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">priority-queue</td>
<td align="left"></td>
<td align="left">multiset</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">multimap</td>
</tr>
<tr>
<td align="left">slist</td>
<td align="left"></td>
<td align="left">hashtable</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">deque</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">hash_set</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">stack</td>
<td align="left"></td>
<td align="left">hash_map</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">queue</td>
<td align="left"></td>
<td align="left">hash_multiset</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">hash_multimap</td>
</tr>
</tbody></table>
<p><em>每一大列第二格是第一格的衍生</em></p>
<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>如下代码所示，先来看看vector内部的成员变量，vector是一个线性空间，由三个变量分别记录使用情况和容量，非常直观好理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp, class _Alloc &#x3D; __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line">class vector : protected _Vector_base&lt;_Tp, _Alloc&gt; </span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; requirements:</span><br><span class="line"></span><br><span class="line">  __STL_CLASS_REQUIRES(_Tp, _Assignable);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  typedef _Vector_base&lt;_Tp, _Alloc&gt; _Base;</span><br><span class="line">public:</span><br><span class="line">  typedef _Tp value_type;</span><br><span class="line">  typedef value_type* pointer;</span><br><span class="line">  typedef const value_type* const_pointer;</span><br><span class="line">  typedef value_type* iterator;  &#x2F;&#x2F; 迭代器就是普通指针</span><br><span class="line">  typedef const value_type* const_iterator;</span><br><span class="line">  typedef value_type&amp; reference;</span><br><span class="line">  typedef const value_type&amp; const_reference;</span><br><span class="line">  typedef size_t size_type;</span><br><span class="line">  typedef ptrdiff_t difference_type;</span><br><span class="line"></span><br><span class="line">  typedef typename _Base::allocator_type allocator_type;</span><br><span class="line">  allocator_type get_allocator() const &#123; return _Base::get_allocator(); &#125;</span><br><span class="line"></span><br><span class="line">#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION</span><br><span class="line">  typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">  typedef reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line">#else &#x2F;* __STL_CLASS_PARTIAL_SPECIALIZATION *&#x2F;</span><br><span class="line">  typedef reverse_iterator&lt;const_iterator, value_type, const_reference, </span><br><span class="line">                           difference_type&gt;  const_reverse_iterator;</span><br><span class="line">  typedef reverse_iterator&lt;iterator, value_type, reference, difference_type&gt;</span><br><span class="line">          reverse_iterator;</span><br><span class="line">#endif &#x2F;* __STL_CLASS_PARTIAL_SPECIALIZATION *&#x2F;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">#ifdef __STL_HAS_NAMESPACES</span><br><span class="line">  using _Base::_M_allocate;</span><br><span class="line">  using _Base::_M_deallocate;</span><br><span class="line">  using _Base::_M_start;  &#x2F;&#x2F; 表示目前使用空间的头部</span><br><span class="line">  using _Base::_M_finish; &#x2F;&#x2F; 表示目前使用空间的尾部</span><br><span class="line">  using _Base::_M_end_of_storage; &#x2F;&#x2F; 表示目前可用空间的尾部，也就是容量尾部</span><br><span class="line">#endif &#x2F;* __STL_HAS_NAMESPACES *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>再来看看vector容量不够时扩容的算法，都比较简单直观</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; push_back一个元素时扩容算法</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Alloc&gt;</span><br><span class="line">void </span><br><span class="line">vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(iterator __position, const _Tp&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">  if (_M_finish !&#x3D; _M_end_of_storage) &#123;  &#x2F;&#x2F; 空间足够</span><br><span class="line">    construct(_M_finish, *(_M_finish - 1));</span><br><span class="line">    ++_M_finish;</span><br><span class="line">    _Tp __x_copy &#x3D; __x;</span><br><span class="line">    copy_backward(__position, _M_finish - 2, _M_finish - 1);</span><br><span class="line">    *__position &#x3D; __x_copy;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;  &#x2F;&#x2F; 空间不够</span><br><span class="line">    const size_type __old_size &#x3D; size();</span><br><span class="line">    const size_type __len &#x3D; __old_size !&#x3D; 0 ? 2 * __old_size : 1;  &#x2F;&#x2F; 原有空间*2</span><br><span class="line">    iterator __new_start &#x3D; _M_allocate(__len);</span><br><span class="line">    iterator __new_finish &#x3D; __new_start;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      __new_finish &#x3D; uninitialized_copy(_M_start, __position, __new_start);</span><br><span class="line">      construct(__new_finish, __x);</span><br><span class="line">      ++__new_finish;</span><br><span class="line">      __new_finish &#x3D; uninitialized_copy(__position, _M_finish, __new_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND((destroy(__new_start,__new_finish), </span><br><span class="line">                  _M_deallocate(__new_start,__len)));</span><br><span class="line">    destroy(begin(), end());</span><br><span class="line">    _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">    _M_start &#x3D; __new_start;</span><br><span class="line">    _M_finish &#x3D; __new_finish;</span><br><span class="line">    _M_end_of_storage &#x3D; __new_start + __len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 插入多个数据时扩容算法</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp, class _Alloc&gt;</span><br><span class="line">void vector&lt;_Tp, _Alloc&gt;::_M_fill_insert(iterator __position, size_type __n, </span><br><span class="line">                                         const _Tp&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">  if (__n !&#x3D; 0) &#123;</span><br><span class="line">    if (size_type(_M_end_of_storage - _M_finish) &gt;&#x3D; __n) &#123;</span><br><span class="line">      _Tp __x_copy &#x3D; __x;</span><br><span class="line">      const size_type __elems_after &#x3D; _M_finish - __position;</span><br><span class="line">      iterator __old_finish &#x3D; _M_finish;</span><br><span class="line">      if (__elems_after &gt; __n) &#123;</span><br><span class="line">        uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);</span><br><span class="line">        _M_finish +&#x3D; __n;</span><br><span class="line">        copy_backward(__position, __old_finish - __n, __old_finish);</span><br><span class="line">        fill(__position, __position + __n, __x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">        uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);</span><br><span class="line">        _M_finish +&#x3D; __n - __elems_after;</span><br><span class="line">        uninitialized_copy(__position, __old_finish, _M_finish);</span><br><span class="line">        _M_finish +&#x3D; __elems_after;</span><br><span class="line">        fill(__position, __old_finish, __x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      const size_type __old_size &#x3D; size();        </span><br><span class="line">      const size_type __len &#x3D; __old_size + max(__old_size, __n); &#x2F;&#x2F; 当前空间*2 或者加新加的元素个数</span><br><span class="line">      iterator __new_start &#x3D; _M_allocate(__len);</span><br><span class="line">      iterator __new_finish &#x3D; __new_start;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        __new_finish &#x3D; uninitialized_copy(_M_start, __position, __new_start);</span><br><span class="line">        __new_finish &#x3D; uninitialized_fill_n(__new_finish, __n, __x);</span><br><span class="line">        __new_finish</span><br><span class="line">          &#x3D; uninitialized_copy(__position, _M_finish, __new_finish);</span><br><span class="line">      &#125;</span><br><span class="line">      __STL_UNWIND((destroy(__new_start,__new_finish), </span><br><span class="line">                    _M_deallocate(__new_start,__len)));</span><br><span class="line">      destroy(_M_start, _M_finish);</span><br><span class="line">      _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">      _M_start &#x3D; __new_start;</span><br><span class="line">      _M_finish &#x3D; __new_finish;</span><br><span class="line">      _M_end_of_storage &#x3D; __new_start + __len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>内部实现是环形双向列表，在末尾提供一个空的node作为头部，或者尾部，其前后指针都指向自己。遍历list的时候，这个节点作为end节点，提供哨兵的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct _List_node_base &#123;</span><br><span class="line">  _List_node_base* _M_next;</span><br><span class="line">  _List_node_base* _M_prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp&gt;</span><br><span class="line">struct _List_node : public _List_node_base &#123;</span><br><span class="line">  _Tp _M_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>是一个双向开口的连续线性空间。虽然说是整体连续的，但是实际上是一段一段定量连续空间拼凑起来的。整体构造如下图所示：</p>
<p>deque由一个中控map来管理所有的存储块，其迭代器如下图所示：</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>封装了一下deque的接口，LIFO，没有迭代器</p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>封装了一下deque的接口，FIFO，没有迭代器</p>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/29/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%BF%AD%E4%BB%A3%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/29/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="post-title-link" itemprop="url">stl源码剖析-迭代器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-01-29 15:15:35 / 修改时间：16:40:16" itemprop="dateCreated datePublished" datetime="2021-01-29T15:15:35+08:00">2021-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/stl/" itemprop="url" rel="index"><span itemprop="name">stl</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Traits编程技法"><a href="#Traits编程技法" class="headerlink" title="Traits编程技法"></a>Traits编程技法</h1><blockquote>
<p>偏特化（partial specialization）：如果class template拥有一个以上的template参数，我么可以针对其中某个（或数个，但非全部）template参数进行特化工作。即，在泛化设计中提供一个特化版本。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">struct iterator_traits &#123;</span><br><span class="line">    typedef typename T::iterator_category iterator_category;  &#x2F;&#x2F; 遍历策略：只读，只写，允许写入型算法读写操作，双向移动，随机读写</span><br><span class="line">    typedef typename T::value_type        value_type;   &#x2F;&#x2F; 值类型</span><br><span class="line">    typedef typename T::difference_type   difference_type;  &#x2F;&#x2F; 两个迭代器之间距离类型</span><br><span class="line">    typedef typename T::pointer           pointer;   &#x2F;&#x2F; 迭代器所指类型指针：左值</span><br><span class="line">    typedef typename T::reference         reference;  &#x2F;&#x2F; 值引用类型： 左值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上面是stl中迭代器需要指定的几种数据类型，函数模板通过这几种模板类型来操作相关数据，</span><br><span class="line">而真正的数据对象类型会根据传入的数据类型进行相应的调整。</span><br><span class="line"> </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct flag_traits &#123;</span><br><span class="line">    typedef typename T::value_type   value_type;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">struct B_tag &#123;&#125;;</span><br><span class="line">struct D1_tag ：public B_tag &#123;&#125;;</span><br><span class="line">struct D2_tag : public D1_tag &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">template &lt;class I&gt;</span><br><span class="line">func(I&amp; p, B_tag) &#123;</span><br><span class="line">    cout &lt;&lt; &quot; B version &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">template &lt;class I&gt;</span><br><span class="line">func(I&amp; p, D2_tag) &#123;</span><br><span class="line">    cout &lt;&lt; &quot; D2 version &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">template &lt;class I&gt;</span><br><span class="line">func(I&amp; p) &#123;</span><br><span class="line">    func(p, typename flag_traits&lt;I&gt;::value_type());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class B &#123;</span><br><span class="line">    typedef B_tag  value_type;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class D1 &#123;</span><br><span class="line">    typedef D1_tag value_type;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class D2 &#123;</span><br><span class="line">    typedef D2_tag  value_type;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    B b;</span><br><span class="line">    D1 d1;</span><br><span class="line">    D2 d2;</span><br><span class="line">    func(b);</span><br><span class="line">    func(d1);</span><br><span class="line">    func(d2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">可以通过flag_traits::value_type的方式来推导当前调用的函数是哪个函数的重载。</span><br><span class="line">这种通过设定一个模板类，间接推导参数类型的方式值得学习。</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/29/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-allocator%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/29/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-allocator%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8/" class="post-title-link" itemprop="url">stl源码剖析-allocator空间分配器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-01-29 15:14:27 / 修改时间：16:40:04" itemprop="dateCreated datePublished" datetime="2021-01-29T15:14:27+08:00">2021-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/stl/" itemprop="url" rel="index"><span itemprop="name">stl</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一二级分配器"><a href="#一二级分配器" class="headerlink" title="一二级分配器"></a>一二级分配器</h1><p>sgi stl为了内存分配效率，采用了两级分配器。</p>
<h2 id="第一级分配器"><a href="#第一级分配器" class="headerlink" title="第一级分配器"></a>第一级分配器</h2><p>template<br>class __malloc_alloc_template {…};<br>其中：</p>
<ol>
<li>allocate()直接使用malloc(), deallocate()直接使用free()。</li>
<li>模拟c++的set_new_handler()以处理内存不足的情况</li>
</ol>
<h2 id="第二级分配器"><a href="#第二级分配器" class="headerlink" title="第二级分配器"></a>第二级分配器</h2><p>template<br>class __default_alloc_template {…};<br>其中：</p>
<ol>
<li>维护16个自由链表（free lists），负责16种小型区块的次配置能力。内存池以malloc配置而得，如果内存不足，转调用第一级分配器（那里有处理程序）。</li>
<li>如果需求的区块大于128 bytes, 就转调用第一级分配器。</li>
</ol>
<h2 id="内存管理小技巧"><a href="#内存管理小技巧" class="headerlink" title="内存管理小技巧"></a>内存管理小技巧</h2><p>第二级分配器管理的16个自由链表的时候，对于每个块，采用了如下所示数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union obj &#123;</span><br><span class="line">    union obj* free_list_link;</span><br><span class="line">    char client_data[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>当分配出去时，用户看到的是client_data部分，丝毫不浪费空间</li>
<li>当空闲时，可以设置free_list_link将各个空闲块链接起来</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/29/Dynamo-Amazon-s-Highly-Available-Key-value-Store/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/29/Dynamo-Amazon-s-Highly-Available-Key-value-Store/" class="post-title-link" itemprop="url">Dynamo Amazon's Highly Available Key-value Store</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-01-29 15:00:59 / 修改时间：15:13:15" itemprop="dateCreated datePublished" datetime="2021-01-29T15:00:59+08:00">2021-01-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>Abstract<br>介绍Dynamo，一个分布式的kv存储系统，具有非常高的可用性和可靠性</p>
</blockquote>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="主要目标："><a href="#主要目标：" class="headerlink" title="主要目标："></a>主要目标：</h2><ol>
<li>Reliability</li>
<li>Scalability</li>
<li>提供key-value接口（最受欢迎清单，购物车，用户偏好等）</li>
</ol>
<h2 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h2><ol>
<li>使用一致性哈希进行数据分区和备份</li>
<li>使用对象版本信息来处理单个数据备份一致性问题</li>
<li>多副本之间的一致性可以通过类似quorum的协议处理（NWR），以及一个去中心化的副本同步协议</li>
<li>使用gossip分布式算法来实现错误发现和成员关系变更协议</li>
</ol>
<h1 id="BackGround"><a href="#BackGround" class="headerlink" title="BackGround"></a>BackGround</h1><ol>
<li>RDBMS太重，不需要那么多复杂查询和管理函数；扩展性差，负载均衡效果差。</li>
</ol>
<h2 id="系统假设和要求"><a href="#系统假设和要求" class="headerlink" title="系统假设和要求"></a>系统假设和要求</h2><ul>
<li>Query Model: 只需要key-value的操作，不需要关系模式（表格），没有跨多个数据（多列）的操作。</li>
<li>ACID：只需要弱一致性，不用提供事务隔离机制。</li>
<li>Efficiency：需要满足严格的SLA</li>
<li>其他的假设：不需要认证，规模只用到几百</li>
</ul>
<h2 id="SLA"><a href="#SLA" class="headerlink" title="SLA"></a>SLA</h2><p>平均，中位数等指标不能很好的反映所有的用户获得很好的服务质量，它们只能反映大部分用户的服务质量，对于长尾延迟不能反映出来。<br>99.9% 延迟则可以反映所有的用户都有一个很好的服务质量。</p>
<h2 id="设计考虑"><a href="#设计考虑" class="headerlink" title="设计考虑"></a>设计考虑</h2><ol>
<li>支持强一致性的系统的可用性不高，为了提高可用性，一般使用弱一致性。弱一致性会导致副本冲突，而解决副本冲突需要两方面的考虑：<ol>
<li>什么时候解决冲突</li>
<li>谁来解决冲突</li>
</ol>
</li>
<li>dynamo采用最终一致性模型。对于冲突解决，它有以下考虑：<ol>
<li>许多模型采用写的时候解决冲突的方式，这样可以让读的逻辑保持比较简单，但是写容易失败。而dynamo相反，为了保证写可用性，让读来解决冲突</li>
<li>dynamo采用用户来解决冲突的方式，而不是后端存储系统自己解决冲突。因为用户知道数据模式，它可以决定最适合的方式解决冲突。而后端存储系统可以采用的策略就比较有限，比如最后更新的是最终的结果这种方式。</li>
</ol>
</li>
<li>增量扩展性：可以无缝扩展集群</li>
<li>对称性：dynamo的所有node都是对等的</li>
<li>去中心化：dynamo不是中心化结构而是端对端结构</li>
<li>异构性：对于不同性能的机器，可以根据性能来分配任务</li>
</ol>
<h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><ol>
<li>p2p系统</li>
<li>分布式文件系统和数据库</li>
<li>讨论<ol>
<li>dynamo 的目标是总是可写</li>
<li>dynamo 的机器都是可信的（不存在恶意机器）</li>
<li>dynamo 不需要层次化的名字空间或者关系模式，只用扁平的模式</li>
<li>dynamo 的性能指标是99.9%的延迟</li>
</ol>
</li>
</ol>
<h1 id="System-Architecture"><a href="#System-Architecture" class="headerlink" title="System Architecture"></a>System Architecture</h1><p>对于生产系统中一个存储系统需要考虑以下方面：</p>
<ol>
<li>负载均衡</li>
<li>成员变动</li>
<li>失败发现</li>
<li>失败恢复</li>
<li>副本同步</li>
<li>超负荷处理</li>
<li>状态转移</li>
<li>并发和任务调度</li>
<li>请求包装（序列化和反序列化）</li>
<li>请求路由</li>
<li>系统监控和报警</li>
<li>配置管理</li>
<li>持久化</li>
<li>数据分区</li>
<li>扩展性</li>
</ol>
<h2 id="dynamo接口"><a href="#dynamo接口" class="headerlink" title="dynamo接口"></a>dynamo接口</h2><ol>
<li>get</li>
<li>put</li>
</ol>
<h2 id="数据分区算法"><a href="#数据分区算法" class="headerlink" title="数据分区算法"></a>数据分区算法</h2><p>一致性哈希算法，如图所示：<br><a target="_blank" rel="noopener" href="https://mychaow.github.io/2018/02/03/dynamo-md/"><img src="https://mychaow.github.io/2018/02/03/dynamo-md/" alt="img"></a><br>基本的一致性哈希算法有以下问题：</p>
<ol>
<li>数据和负载分布不均衡</li>
<li>对于不同机器体现不出异构性</li>
</ol>
<p>采用virtual nodes来解决这个问题，具体的就是每个节点映射多个虚拟节点，虚拟节点组成一个哈希环，有以下好处：</p>
<ol>
<li>一个节点失败了，它的负载会被剩下的所有节点平分</li>
<li>当一个节点加入时，以前的所有节点会将一小部分负载分给它，非常快</li>
<li>虚拟节点数可以反映一个机器的性能，当机器性能高时，可以多映射一点虚拟节点，这样就可以处理更多的负载</li>
</ol>
<h2 id="数据副本"><a href="#数据副本" class="headerlink" title="数据副本"></a>数据副本</h2><ol>
<li>使用N备份，就是一个key落在哈希环上映射的第一个节点，顺时针的往下找N-1个节点作为备份节点。这N个节点称为preference list。</li>
<li>这N个节点要保证是物理节点，防止都是同一个节点的虚拟节点，没有达到备份的效果</li>
</ol>
<h2 id="数据版本"><a href="#数据版本" class="headerlink" title="数据版本"></a>数据版本</h2><p>使用向量时钟来作为数据版本号，最终表示为一系列（node，counter）。</p>
<ol>
<li>当一个版本的对象的所有（node，counter）对都小于或等于另外一个版本的对象，则该对象是另外对象的祖先</li>
<li>dynamo中当一个用户想要更新一个对象时，需要提供上一次读的操作的版本号，用来指定是对某个版本的对象实现更新操作</li>
</ol>
<p>向量时钟表示版本，有一点需要考虑的是：当多个节点并发更新后，（node, counter）对就会变得很多，合并起来占用空间，因此可以设置一个阈值，超过该阈值，从最旧的开始截断。现实中其实很少发现这种需要截断的情况。</p>
<h2 id="get和put操作的执行"><a href="#get和put操作的执行" class="headerlink" title="get和put操作的执行"></a>get和put操作的执行</h2><ol>
<li>用户感知存储节点<ol>
<li>通过一个通用的负载均衡节点来路由选，好处是用户与存储节点解耦</li>
<li>使用自带分区感知能力的client lib库来访问，好处是用户的延迟更低</li>
</ol>
</li>
<li>数据副本一致性<ol>
<li>R + W &gt; N</li>
<li>前N个node作为preference node，选择其中一个作为coordinator来处理读写请求。</li>
</ol>
</li>
</ol>
<h2 id="处理失败"><a href="#处理失败" class="headerlink" title="处理失败"></a>处理失败</h2><p>考虑到严格的R+W&gt;N在网络分区，或临时坏的情况下还是影响可用性，因此可以除了N个preference节点外，对于每个机器设置备份节点<br>Hinted replica，当某个节点不可用时，就把数据发送给它的hinted replica。<br>Dynamo的节点是跨地域的，所以可以提供跨地域可用性。</p>
<h2 id="处理持久化失败"><a href="#处理持久化失败" class="headerlink" title="处理持久化失败"></a>处理持久化失败</h2><p>当Hinted replica的节点也不可用时，数据的持久化就会有危险。为了达到数据写入的安全性，需要副本之间同步新的数据并互为备份。为了发现<br>不同的副本之间的不一致性。使用Merkle trees算法。这个算法就是将不同的key区间进行哈希，父节点是子节点的哈希值的哈希，这样每个<br>节点构造自己的Merkle trees，然后相互比较就能很快的知道哪里不一致了。</p>
<h2 id="成员管理和失败发现"><a href="#成员管理和失败发现" class="headerlink" title="成员管理和失败发现"></a>成员管理和失败发现</h2><ol>
<li>哈希环成员</li>
</ol>
<p>使用基于Gossip算法的协议来传播成员变更信息。</p>
<ol>
<li>外部发现</li>
</ol>
<p>为了防止逻辑分区，设置一些seed节点，让所有的节点与它们通信来获得最终的集群成员信息。</p>
<ol>
<li>错误发现</li>
</ol>
<p>每个节点使用基于Gossip算法来感知其他节点可不可达的信息。</p>
<h2 id="添加和移除节点"><a href="#添加和移除节点" class="headerlink" title="添加和移除节点"></a>添加和移除节点</h2><p>每个节点加入哈希环时，相关节点向它发送key value。当移除时，该节点向映射的其他节点发送key value对。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol>
<li>请求协调者</li>
<li>成员管理和失败发现</li>
<li>本地持久化引擎</li>
</ol>
<h2 id="本地持久化引擎"><a href="#本地持久化引擎" class="headerlink" title="本地持久化引擎"></a>本地持久化引擎</h2><p>支持多种引擎，比如mysql，Berkeley DB</p>
<h2 id="请求协调者"><a href="#请求协调者" class="headerlink" title="请求协调者"></a>请求协调者</h2><ol>
<li>使用事件驱动的方式编写，即状态机。每个状态机处理一个用户请求。根据不同的阶段做对应的处理。</li>
<li>put的时候，preference list top N个节点任意一个都可以处理。为了获得更好的一致性，一般写会挑上一次读的时候最快返回结果的节点，这样下次读还是有很大概率读到最新的值。</li>
</ol>
<h1 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h1><p>冲突解决方案：</p>
<ol>
<li>业务制定更新冲突解决方法</li>
<li>基于时间序的冲突解决方法</li>
<li>W=N, R=1解决高性能读要求</li>
</ol>
<h2 id="负载均衡性能和持久化性能"><a href="#负载均衡性能和持久化性能" class="headerlink" title="负载均衡性能和持久化性能"></a>负载均衡性能和持久化性能</h2><ol>
<li>使用缓存写来提供系统的写性能</li>
<li>写入的时候指定其中一个副本直接写入到磁盘中，其他的缓存写，这样提高系统数据安全性(持久化)</li>
</ol>
<h2 id="保证系统负载一致性分布"><a href="#保证系统负载一致性分布" class="headerlink" title="保证系统负载一致性分布"></a>保证系统负载一致性分布</h2><p>数据分区和节点映射策略</p>
<ol>
<li><p>每个节点T个随机token，数据分区也是按照token来划分</p>
<p>缺点：</p>
<ol>
<li>新节点加入时，在线节点需要扫描自己的数据集来找到需要传输给新加入节点的数据，影响线上服务。<br>当不想影响线上服务时，降低扫描优先级，会导致新加入节点启动比较慢</li>
<li>节点加入或离开时，许多节点的数据分区和Merkle tree需要重新计算，影响服务</li>
<li>因为数据分区是不固定的，所以没法做snapshot来加快传输数据<br>这个策略不好的根本原因是数据分区和数据放置策略耦合太多</li>
</ol>
</li>
<li><p>每个节点T个随机token，数据是大小固定的划分的</p>
<ol>
<li>哈希空间划分为固定Q个分区，每个节点还是随机分配T个token，其中Q&gt;&gt;N &amp; Q &gt;&gt; S*T S是节点数，N是副本数</li>
<li>每个数据分区以末尾为key顺时针找到下一个token对应的Node<br>优点：</li>
<li>数据放置和数据分区解耦</li>
<li>可以在运行过程中改变数据放置</li>
</ol>
</li>
<li><p>每个节点Q/S个token,数据是大小固定的划分的</p>
<ol>
<li>跟2策略一样，但是T=Q/S，当某个节点离开时，它的token被随机分给其他的节点，<br>当节点加入时，它从别的节点随机拉取token<br>优点：</li>
<li>快速启动和恢复</li>
<li>打包数据（快照）<br>缺点：</li>
<li>改变node 成员关系需要许多节点协作来维持策略3的要求</li>
</ol>
</li>
</ol>
<h2 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h2><p>原因：</p>
<ol>
<li><p>系统出现节点失败和网络分区时</p>
</li>
<li><p>系统处理大量的并发写<br>数量：</p>
</li>
<li><p>数量非常少</p>
<h2 id="客户端驱动或者服务端驱动定位"><a href="#客户端驱动或者服务端驱动定位" class="headerlink" title="客户端驱动或者服务端驱动定位"></a>客户端驱动或者服务端驱动定位</h2></li>
<li><p>服务端驱动</p>
<ol>
<li>coordinator来执行读和写的协调操作</li>
<li>需要负载均衡器来做请求转发和均衡</li>
</ol>
</li>
<li><p>客户端驱动</p>
<ol>
<li>client定期随机向集群某个节点拉取整个集群的在线node 视图</li>
<li>将读写请求发往指定的coordinator</li>
<li>因为数据分区几乎公平的将数据分散到各个节点，所以不用做负载均衡操作</li>
</ol>
</li>
</ol>
<h2 id="前台和后台任务均衡"><a href="#前台和后台任务均衡" class="headerlink" title="前台和后台任务均衡"></a>前台和后台任务均衡</h2><p>后台任务都是低优先级的任务，为了不影响前台任务，需要控制其资源使用量。<br>dynamo使用一个反馈机制来做这种资源使用控制。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>dynamo使用gossip来做全局在线node视图传播，只能达到几百台的规模。更大的规模需要做层次化扩展。</p>
<p><em>总结</em></p>
<p>dynamo这篇论文写的非常详细，比较重要的几点：</p>
<ol>
<li>采用99.9% 来衡量SLA</li>
<li>采用一致性哈希模型的数据分区策略</li>
<li>采用向量时钟来作为数据版本信息，并由业务逻辑来处理版本冲突</li>
<li>采用基于gossip算法来处理集群视图的传播</li>
<li>采用NWR算法来保证数据安全性</li>
<li>采用Merkle trees来加快发现版本之间不一致性，从而快速备份数据</li>
</ol>
<table>
<thead>
<tr>
<th align="left">Problem</th>
<th align="left">Technique</th>
<th align="left">Advantage</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Partitioning</td>
<td align="left">Consistent Hashing</td>
<td align="left">Incremental Scalability</td>
</tr>
<tr>
<td align="left">High Availablility for Writes</td>
<td align="left">Vector clocks with reconsiliation during reads</td>
<td align="left">version size decoupled from update rates</td>
</tr>
<tr>
<td align="left">Handing temporary failures</td>
<td align="left">Sloppy Quorum and hinted handoff</td>
<td align="left">Provides high Availablility and durability guarantee when some fo the replicas are not available</td>
</tr>
<tr>
<td align="left">Recovering from permanent failures</td>
<td align="left">Anti-entropy using Merkle trees</td>
<td align="left">Synchronizes divergent replicas in the BackGround</td>
</tr>
<tr>
<td align="left">membership and failure detection</td>
<td align="left">gossip-based membership protocol and failures detection</td>
<td align="left">preserves symmetry and avoids having a centralized registry for Storing membership and node liveness information</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason Chao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
