<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="事务  属性 原子性（Atomicity）: 事务要么全部完成，要么全部取消。 如果事务崩溃，状态回到事务之前（事务回滚）。 隔离性（Isolation）: 如果2个事务 T1 和 T2 同时运行，事务 T1 和 T2 最终的结果是相同的，不管 T1和T2谁先结束。 持久性（Durability）: 一旦事务提交，不管发生什么（崩溃或者出错），数据要保存在数据库中。 一致性（Consistency">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库simpleDB入门-4">
<meta property="og:url" content="http://example.com/2022/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-4/index.html">
<meta property="og:site_name" content="我住8楼">
<meta property="og:description" content="事务  属性 原子性（Atomicity）: 事务要么全部完成，要么全部取消。 如果事务崩溃，状态回到事务之前（事务回滚）。 隔离性（Isolation）: 如果2个事务 T1 和 T2 同时运行，事务 T1 和 T2 最终的结果是相同的，不管 T1和T2谁先结束。 持久性（Durability）: 一旦事务提交，不管发生什么（崩溃或者出错），数据要保存在数据库中。 一致性（Consistency">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-4/%E4%BA%8B%E5%8A%A1.jpg">
<meta property="og:image" content="http://example.com/2022/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-4/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16417157941254.png">
<meta property="article:published_time" content="2022-01-08T09:32:30.000Z">
<meta property="article:modified_time" content="2022-01-09T12:25:33.012Z">
<meta property="article:author" content="Jason Chao">
<meta property="article:tag" content="database">
<meta property="article:tag" content="simpleDB">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-4/%E4%BA%8B%E5%8A%A1.jpg">


<link rel="canonical" href="http://example.com/2022/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>数据库simpleDB入门-4 | 我住8楼</title><meta name="robots" content="noindex">
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我住8楼</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.</span> <span class="nav-text">并发的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.</span> <span class="nav-text">四种特性实现机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="nav-number">1.4.1.</span> <span class="nav-text">原子性保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="nav-number">1.4.2.</span> <span class="nav-text">隔离性保证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81%EF%BC%88Two-phase-locking-protocol%EF%BC%89"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">两阶段加锁（Two-phase locking protocol）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81%EF%BC%88strict-two-phase-locking-protocol"><span class="nav-number">1.4.2.1.2.</span> <span class="nav-text">严格两阶段加锁（strict two-phase locking protocol)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E4%B8%A5%E6%A0%BC%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81%EF%BC%88rigorous-two-phase-locking-protocol"><span class="nav-number">1.4.2.1.3.</span> <span class="nav-text">更严格两阶段加锁（rigorous two-phase locking protocol)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">时间戳机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">基本方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%98%E9%A9%AC%E6%96%AF%E7%9A%84%E4%BF%AE%E6%94%B9%E8%A7%84%E5%88%99"><span class="nav-number">1.4.2.2.2.</span> <span class="nav-text">托马斯的修改规则</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E6%97%B6%E9%97%B4%E6%88%B3-Multi-Version-Timestamp-Ordering"><span class="nav-number">1.4.2.3.1.</span> <span class="nav-text">多版本时间戳(Multi-Version Timestamp Ordering)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81-Multi-Version-Two-Phase-Locking"><span class="nav-number">1.4.2.3.2.</span> <span class="nav-text">多版本两阶段加锁(Multi-Version Two-Phase Locking)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="nav-number">1.4.3.</span> <span class="nav-text">持久性保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="nav-number">1.4.4.</span> <span class="nav-text">一致性保证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lab4"><span class="nav-number">2.</span> <span class="nav-text">lab4</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E9%94%81"><span class="nav-number">2.1.</span> <span class="nav-text">读写数据锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferPool"><span class="nav-number">2.1.1.</span> <span class="nav-text">BufferPool</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PageLock"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">PageLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BufferPool%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">BufferPool实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-STEAL-amp-FORCE"><span class="nav-number">2.2.</span> <span class="nav-text">NO STEAL&amp;FORCE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#No-Steal"><span class="nav-number">2.2.1.</span> <span class="nav-text">No Steal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FORCE"><span class="nav-number">2.2.2.</span> <span class="nav-text">FORCE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E7%B4%A2%E5%92%8C%E5%A4%84%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">死锁检索和处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason Chao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库simpleDB入门-4
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-08 17:32:30" itemprop="dateCreated datePublished" datetime="2022-01-08T17:32:30+08:00">2022-01-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-09 20:25:33" itemprop="dateModified" datetime="2022-01-09T20:25:33+08:00">2022-01-09</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><img src="/2022/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-4/%E4%BA%8B%E5%8A%A1.jpg" class="" title="事务">

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li>原子性（<strong>A</strong>tomicity）: 事务<code>要么全部完成，要么全部取消</code>。 如果事务崩溃，状态回到事务之前（事务回滚）。</li>
<li>隔离性（<strong>I</strong>solation）: 如果2个事务 T1 和 T2 同时运行，事务 T1 和 T2 最终的结果是相同的，不管 T1和T2谁先结束。</li>
<li>持久性（<strong>D</strong>urability）: 一旦事务提交，不管发生什么（崩溃或者出错），数据要保存在数据库中。</li>
<li>一致性（<strong>C</strong>onsistency）: 只有合法的数据（依照关系约束和函数约束）才能写入数据库。</li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul>
<li>串行化(Serializable，SQLite默认模式）：最高级别的隔离。两个同时发生的事务100%隔离，每个事务有自己的”世界”, 串行执行。</li>
<li>可重复读（Repeatable read，MySQL默认模式）：如果一个事务成功执行并且添加了新数据(事务提交)，这些数据对其他正在执行的事务是可见的。但是如果事务成功修改了一条数据，修改结果对正在运行的事务不可见。所以，事务之间只是在新数据方面突破了隔离，对已存在的数据仍旧隔离。</li>
<li>读取已提交（Read committed，Oracle、PostgreSQL、SQL Server默认模式）：可重复读+新的隔离突破。如果事务A读取了数据D，然后数据D被事务B修改（或删除）并提交，事务A再次读取数据D时数据的变化（或删除）是可见的。这叫不可重复读（non-repeatable read）。</li>
<li>读取未提交（Read uncommitted）：最低级别的隔离，是读取已提交+新的隔离突破。如果事务A读取了数据D，然后数据D被事务B修改（但并未提交，事务B仍在运行中），事务A再次读取数据D时，数据修改是可见的。如果事务B回滚，那么事务A第二次读取的数据D是无意义的，因为那是事务B所做的从未发生的修改（已经回滚了嘛）。这叫脏读（dirty read）。</li>
</ul>
<h2 id="并发的问题"><a href="#并发的问题" class="headerlink" title="并发的问题"></a>并发的问题</h2><ul>
<li><strong>更新丢失</strong>（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——<strong>最后的更新覆盖了其他事务所做的更新</strong>。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题</li>
<li><strong>脏读</strong>：所谓脏读，就是指<strong>事务A读到了事务B还没有提交的数据</strong>，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务–&gt;取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读。</li>
<li><strong>不可重复读</strong>：所谓不可重复读，就是指<strong>在一个事务里面读取了两次某个数据，读出来的数据不一致</strong>。还是以银行取钱为例，事务A开启事务–&gt;查出银行卡余额为1000元，此时切换到事务B事务B开启事务–&gt;事务B取走100元–&gt;提交，数据库里面余额变为900元，此时切换回事务A，事务A再查一次查出账户余额为900元，这样对事务A而言，在同一个事务内两次读取账户余额数据不一致，这就是不可重复读。</li>
<li><strong>幻读</strong>：所谓幻读，就是指<strong>在一个事务里面的操作中发现了未被操作的数据</strong>。比如学生信息，事务A开启事务–&gt;修改所有学生当天签到状况为false，此时切换到事务B，事务B开启事务–&gt;事务B插入了一条学生数据，此时切换回事务A，事务A提交的时候发现了一条自己没有修改过的数据，这就是幻读，就好像发生了幻觉一样。幻读出现的前提是并发的事务中有事务<strong>发生了插入、删除操作</strong>。</li>
</ul>
<h2 id="四种特性实现机制"><a href="#四种特性实现机制" class="headerlink" title="四种特性实现机制"></a>四种特性实现机制</h2><h3 id="原子性保证"><a href="#原子性保证" class="headerlink" title="原子性保证"></a>原子性保证</h3><p>当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p>
<p>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p>
<h3 id="隔离性保证"><a href="#隔离性保证" class="headerlink" title="隔离性保证"></a>隔离性保证</h3><h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><h5 id="两阶段加锁（Two-phase-locking-protocol）"><a href="#两阶段加锁（Two-phase-locking-protocol）" class="headerlink" title="两阶段加锁（Two-phase locking protocol）"></a>两阶段加锁（Two-phase locking protocol）</h5><p>1）获取锁阶段(growing phase)：在这个过程中，事务只能不断地获取新的锁，但不能释放锁。</p>
<p>2）释放锁阶段(shrinking phase)：在这个过程中，事务只能逐渐释放锁，并且无权再获取新的锁</p>
<p>问题：</p>
<ol>
<li>级联回滚:</li>
</ol>
<h5 id="严格两阶段加锁（strict-two-phase-locking-protocol"><a href="#严格两阶段加锁（strict-two-phase-locking-protocol" class="headerlink" title="严格两阶段加锁（strict two-phase locking protocol)"></a>严格两阶段加锁（strict two-phase locking protocol)</h5><p>除了需要遵循加锁和释放锁的两阶段外，它还规定，对于独占锁(X-lock)必须等到事务结束时才释放。</p>
<p>这个规定避免了其他事务对未提交的数据进行读写操作，因此也避免了连锁回滚。</p>
<h5 id="更严格两阶段加锁（rigorous-two-phase-locking-protocol"><a href="#更严格两阶段加锁（rigorous-two-phase-locking-protocol" class="headerlink" title="更严格两阶段加锁（rigorous two-phase locking protocol)"></a>更严格两阶段加锁（rigorous two-phase locking protocol)</h5><p>规定了所有获得的锁都得等到事务结束时才释放</p>
<h4 id="时间戳机制"><a href="#时间戳机制" class="headerlink" title="时间戳机制"></a>时间戳机制</h4><h5 id="基本方式"><a href="#基本方式" class="headerlink" title="基本方式"></a>基本方式</h5><p>对于事务 Ti 要读取数据 A read(A):</p>
<ul>
<li>如果 TS(Ti) &lt; W-timestamp(A)，说明 A 被一个 TS 比 Ti 更大的事务改写过，但 Ti 只能读取比自身 TS 小的数据。因此 Ti 的读取请求会被拒绝，Ti 会被回滚。</li>
<li>如果 TS(Ti) &gt; W-timestamp(A)，说明 A 最近一次被修改小于 TS(Ti)，因此读取成功，并且，R-timestamp(A)被改写为 TS(Ti)。</li>
</ul>
<p>对于事务 Ti 要修改数据 A write(A):</p>
<ul>
<li>如果 TS(Ti) &lt; R-timestamp(A)，说明 A 已经被一个更大 TS 的事务读取了，Ti 对 A 的修改就没有意义了，因此 Ti 的修改请求会被拒绝，Ti 会被回滚。</li>
<li>如果 TS(Ti) &lt; W-timestamp(A)，说明 A 已经被一个更大 TS 的事务修改了，Ti 对 A 的修改也没有意义了，因此 Ti 的修改请求会被拒绝，Ti 会被回滚。</li>
<li>其他情况下，Ti 的修改会被接受，同时 W-timestamp(A)会被改写为 TS(Ti)。</li>
</ul>
<p>一旦一个事务因为任何原因被回滚，再次重新执行时，会被系统分配一个新的 TS。</p>
<h5 id="托马斯的修改规则"><a href="#托马斯的修改规则" class="headerlink" title="托马斯的修改规则"></a>托马斯的修改规则</h5><p><strong>问题：</strong></p>
<p>基本机制同时也避免了死锁，虽然有可能导致饥饿(starvation)：某些运气不好的长事务因为不停地失败被回滚然后重试。</p>
<p>有什么方法能够让时间戳机制进一步提高并发性？</p>
<p>这个改进策略被称为<strong>托马斯的修改规则</strong>(Thomas’ write rule): 假设 Ti 要 write(A):</p>
<ul>
<li>如果 TS(Ti) &lt; R-timestamp(A)，说明 A 已经被一个更大 TS 的事务读取了，Ti 对 A 的修改就没有意义了，因此 Ti 的修改请求会被拒绝，Ti 会被回滚。</li>
<li>如果 TS(Ti) &lt; W-timestamp(A)，说明 Ti 的修改没有意义，因此这个修改操作会被忽略。</li>
<li>其他情况下，Ti 的修改会被接受，同时 W-timestamp(A)会被改写为 TS(Ti)。</li>
</ul>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><h5 id="多版本时间戳-Multi-Version-Timestamp-Ordering"><a href="#多版本时间戳-Multi-Version-Timestamp-Ordering" class="headerlink" title="多版本时间戳(Multi-Version Timestamp Ordering)"></a>多版本时间戳(Multi-Version Timestamp Ordering)</h5><p><strong>基本定义</strong>：</p>
<ul>
<li>当前版本的数据值</li>
<li>W-TS(Qx): 当 Qx 被某个事务 Ti 创建的时间戳，即 TS(Ti)</li>
<li>R-TS(Qx): 由于一个版本的数据可以被多个事务读取，这里存储的是最大的事务时间戳：最近一次被某个事务 Tj 读取成功的时间戳，即 TS(Tj)</li>
</ul>
<p><strong>机制</strong>：</p>
<p>给定当前事务 Ti 对数据 Q 发起了一个读操作 read(Q)或者写操作 write(Q)。并假定，版本 Qk 是 Q 的所有版本中持有最大的但小于或等于 TS(Ti)的 W-TS 的时间戳。则：</p>
<ul>
<li>如果 Ti 是读操作，则读取成功，返回 Qk 中的值给 Ti。</li>
<li>如果 Ti 是写操作，则需要判断，如果 TS(Ti) &lt; R-TS(Qx)，即说明有一个更新的事务已经读取了数据，因此系统判定更新失败，回滚 Ti。如果 TS(Ti) = W-TS(Qx)，系统可以直接将 Ti 的值覆盖 Qk 的原值；如果 TS(Ti) &gt; R-TS(Qx)，则创建一个新的版本 Q。</li>
</ul>
<p><strong>优点</strong>：</p>
<p>多版本时间戳机制的一大好处在于，一个读取数据的事务永远不会失败也不需要等待。在一个读多写少的场景下，相比于先前介绍的两种机制，会有很好的性能提升。</p>
<p><strong>缺点</strong>：</p>
<p>当然，它也是有缺点的。首先，就是在读取操作的事务中，也需要更新相应的 R-TS(Qk)，并且读取数据，这就导致可能产生两次磁盘操作，而非只读一次。另外，当写操作发生冲突时，它会要求回滚失败的事务，相比起等待，回滚操作可能更昂贵一些。</p>
<h5 id="多版本两阶段加锁-Multi-Version-Two-Phase-Locking"><a href="#多版本两阶段加锁-Multi-Version-Two-Phase-Locking" class="headerlink" title="多版本两阶段加锁(Multi-Version Two-Phase Locking)"></a>多版本两阶段加锁(Multi-Version Two-Phase Locking)</h5><p><strong>机制</strong>：</p>
<ul>
<li>有更新数据的事务会遵守两阶段加锁的规则，即事务需要持有所有的锁直至事务结束。这样，这些事务就能够保证有序性(在介绍 两阶段加锁的时候已经讲解过)。这样做的好处在于不同的写事务可以等待并且按照顺序依次完成而不需要回滚后重试。</li>
<li>当事务需要写数据时，首先要获取数据的独占锁并且创建一个新的版本，并把版本的时间戳设置为无穷大，当这个事务要被提交时，把它锁创建的所有数据的新版本的时间戳设置为 TS-Counter+1，并且同时更新系统的 TS-Counter，也变为 TS-Counter+1。</li>
<li>对于只读操作的事务 Ti，数据库系统会把 TS(Ti)赋于当前 TS-Counter 的值，这样 Ti 读取数据就和上面介绍的多版本时间戳一样，会读取到最大的但小于或等于 TS(Ti)的 Q 版本的值。</li>
</ul>
<h3 id="持久性保证"><a href="#持久性保证" class="headerlink" title="持久性保证"></a>持久性保证</h3><p>当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p>
<p>既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</p>
<p>1、刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。</p>
<p>2、刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少</p>
<h3 id="一致性保证"><a href="#一致性保证" class="headerlink" title="一致性保证"></a>一致性保证</h3><ul>
<li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li>
<li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li>
<li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。</li>
</ul>
<p>事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障</p>
<h1 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h1><p>如下图所示，事务涉及到数据存储这一块的内容，主要是数据的读写的并发。</p>
<img src="/2022/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-4/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16417157941254.png" class="" title="img">

<p>​    为了简化实现，本次实验不考虑失败恢复的可能。</p>
<h2 id="读写数据锁"><a href="#读写数据锁" class="headerlink" title="读写数据锁"></a>读写数据锁</h2><p>机制：</p>
<ul>
<li>在一个事务要读取一个对象前，需要获取该对象的共享锁</li>
<li>在一个事务要更新一个对象前，需要获取该对象的独占锁</li>
<li>多个事务可以同时获取同一个对象的共享锁</li>
<li>只有一个事务可以获取一个对象的独占锁</li>
<li>如果某个事务是某个对象的共享锁唯一获得者，该事务可以升级为独占锁</li>
</ul>
<h3 id="BufferPool"><a href="#BufferPool" class="headerlink" title="BufferPool"></a>BufferPool</h3><p>因为数据读写都是通过BufferPool，因此在BufferPool里加上锁来实现事务的隔离。</p>
<h4 id="PageLock"><a href="#PageLock" class="headerlink" title="PageLock"></a>PageLock</h4><p>数据从磁盘读写的粒度是Page级别，为每个Page定义一把锁，如下所示。主要字段是：</p>
<ol>
<li>一把可重入锁(独占锁)用来保护字段更新不会有问题</li>
<li>一个条件变量</li>
<li>随机超时器</li>
<li>独占锁的事务id</li>
<li>共享锁的事务id列表</li>
</ol>
<p>主要思路在代码注释里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line">    <span class="keyword">private</span> TransactionId tid; <span class="comment">// write lock holder</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;TransactionId&gt; sharedTids; <span class="comment">// read lock holder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIME_OUT = <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">    PageLock() &#123;</span><br><span class="line">      lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">      condition = lock.newCondition();</span><br><span class="line">      tid = <span class="keyword">null</span>;</span><br><span class="line">      sharedTids = <span class="keyword">new</span> ConcurrentSkipListSet&lt;&gt;();</span><br><span class="line">      random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReadLock</span><span class="params">(TransactionId tid)</span> <span class="keyword">throws</span> TransactionAbortedException </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> nano = TimeUnit.MILLISECONDS.toNanos(TIME_OUT + random.nextInt(<span class="number">1000</span>));</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前没有人获得独占锁，或者本事务当前获得了独占锁，或者自己本来就获得了共享锁</span></span><br><span class="line">        <span class="comment">// 那就加锁成功，把自己加入到共享锁事务列表里</span></span><br><span class="line">        <span class="comment">// 否则就等待一个随机时间，如果等到独占锁释放，那就继续加锁，否则就抛出事务终止异常</span></span><br><span class="line">        <span class="keyword">while</span> (!(<span class="keyword">this</span>.tid == <span class="keyword">null</span> || <span class="keyword">this</span>.tid == tid || sharedTids.contains(tid))) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nano &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransactionAbortedException();</span><br><span class="line">          &#125;</span><br><span class="line">          nano = condition.awaitNanos(nano);</span><br><span class="line">        &#125;</span><br><span class="line">        sharedTids.add(tid);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransactionAbortedException();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReadUnlock</span><span class="params">(TransactionId tid)</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        sharedTids.remove(tid);</span><br><span class="line">        condition.signalAll();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WriteLock</span><span class="params">(TransactionId tid)</span> <span class="keyword">throws</span> TransactionAbortedException </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> nano = TimeUnit.MILLISECONDS.toNanos(TIME_OUT  + random.nextInt(<span class="number">1000</span>));</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前事务获得过独占锁，那就直接返回成功</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tid == tid) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前没有人获得独占锁，或者只有自己本来就获得了共享锁</span></span><br><span class="line">        <span class="comment">// 那就加锁成功，把自己的事务id记下来</span></span><br><span class="line">        <span class="comment">// 否则就等待一个随机时间，如果等到独占锁释放，那就继续加锁，否则就抛出事务终止异常</span></span><br><span class="line">        <span class="keyword">while</span> (!(<span class="keyword">this</span>.tid == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (sharedTids.isEmpty()</span><br><span class="line">                || (sharedTids.size() == <span class="number">1</span> &amp;&amp; sharedTids.contains(tid))))) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nano &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransactionAbortedException();</span><br><span class="line">          &#125;</span><br><span class="line">          nano = condition.awaitNanos(nano);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.tid = tid;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransactionAbortedException();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WriteUnlock</span><span class="params">(TransactionId tid)</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tid != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.tid == tid) &#123;</span><br><span class="line">          <span class="keyword">this</span>.tid = <span class="keyword">null</span>;</span><br><span class="line">          condition.signalAll();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upgradeLock</span><span class="params">(TransactionId tid)</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sharedTids.size() == <span class="number">1</span> &amp;&amp; sharedTids.contains(tid)) &#123;</span><br><span class="line">          <span class="keyword">this</span>.tid = tid;</span><br><span class="line">          sharedTids.remove(tid);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasReadLock</span><span class="params">(TransactionId tid)</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sharedTids.contains(tid);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasWriteLock</span><span class="params">(TransactionId tid)</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.tid == tid;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasLock</span><span class="params">(TransactionId tid)</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sharedTids.contains(tid) || <span class="keyword">this</span>.tid == tid;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(TransactionId tid)</span> </span>&#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tid != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.tid == tid) &#123;</span><br><span class="line">          <span class="keyword">this</span>.tid = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sharedTids.remove(tid);</span><br><span class="line">        condition.signalAll();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;PageLock&#123;&quot;</span> +</span><br><span class="line">          <span class="string">&quot;lock=&quot;</span> + lock +</span><br><span class="line">          <span class="string">&quot;, tid=&quot;</span> + tid +</span><br><span class="line">          <span class="string">&quot;, sharedTids=&quot;</span> + sharedTids +</span><br><span class="line">          <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="BufferPool实现"><a href="#BufferPool实现" class="headerlink" title="BufferPool实现"></a>BufferPool实现</h4><p>除了记录每个页的数据内容，还记录每个页的锁。</p>
<p>根据上述规则，对于读页，释放页，判断是否获取锁添加对应的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BufferPool manages the reading and writing of pages into memory from</span></span><br><span class="line"><span class="comment"> * disk. Access methods call into it to retrieve pages, and it fetches</span></span><br><span class="line"><span class="comment"> * pages from the appropriate location.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The BufferPool is also responsible for locking;  when a transaction fetches</span></span><br><span class="line"><span class="comment"> * a page, BufferPool checks that the transaction has the appropriate</span></span><br><span class="line"><span class="comment"> * locks to read/write the page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferPool</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Bytes per page, including header.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_SIZE = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Default number of pages passed to the constructor. This is used by</span></span><br><span class="line"><span class="comment">   * other classes. BufferPool should use the numPages argument to the</span></span><br><span class="line"><span class="comment">   * constructor instead.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PAGES = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(BufferPool.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ReentrantLock reentrantLock; <span class="comment">// lock the following two maps</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;PageId, Page&gt; pages;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;PageId, PageLock&gt; pageLockMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;PageId&gt; lru;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> numPages;</span><br><span class="line">  <span class="keyword">private</span> TransactionId tid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a BufferPool that caches up to numPages pages.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> numPages maximum number of pages in this buffer pool.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BufferPool</span><span class="params">(<span class="keyword">int</span> numPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    pages = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(numPages);</span><br><span class="line">    <span class="keyword">this</span>.numPages = numPages;</span><br><span class="line">    lru = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    pageLockMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Retrieve the specified page with the associated permissions.</span></span><br><span class="line"><span class="comment">   * Will acquire a lock and may block if that lock is held by another</span></span><br><span class="line"><span class="comment">   * transaction.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * The retrieved page should be looked up in the buffer pool.  If it</span></span><br><span class="line"><span class="comment">   * is present, it should be returned.  If it is not present, it should</span></span><br><span class="line"><span class="comment">   * be added to the buffer pool and returned.  If there is insufficient</span></span><br><span class="line"><span class="comment">   * space in the buffer pool, an page should be evicted and the new page</span></span><br><span class="line"><span class="comment">   * should be added in its place.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> tid  the ID of the transaction requesting the page</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pid  the ID of the requested page</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> perm the requested permissions on the page</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Page <span class="title">getPage</span><span class="params">(TransactionId tid, PageId pid, Permissions perm)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> TransactionAbortedException, DbException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    logger.info(<span class="string">&quot;get page &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, tid, pid, perm);</span><br><span class="line">    <span class="keyword">if</span> (pages.containsKey(pid)) &#123;</span><br><span class="line">      PageLock pageLock = pageLockMap.get(pid);</span><br><span class="line">      <span class="keyword">if</span> (perm == Permissions.READ_ONLY) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;get read lock &#123;&#125;&quot;</span>, pageLock);</span><br><span class="line">        pageLock.ReadLock(tid);</span><br><span class="line">        logger.info(<span class="string">&quot;end get read lock &#123;&#125;&quot;</span>, pageLock);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (perm == Permissions.READ_WRITE) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;get write lock &#123;&#125;&quot;</span>, pid);</span><br><span class="line">        pageLock.WriteLock(tid);</span><br><span class="line">        logger.info(<span class="string">&quot;end get wirte lock &#123;&#125;, &#123;&#125;&quot;</span>, pid, pageLock);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> pages.get(pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pages.size() &gt;= numPages) &#123;</span><br><span class="line">      evictPage();</span><br><span class="line"><span class="comment">//            throw new DbException(&quot;no more pages&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pages.size() &gt;= numPages) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> DbException(<span class="string">&quot;no more pages&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Page cur = Database.getCatalog().getDbFile(pid.getTableId()).readPage(pid);</span><br><span class="line">    PageLock pageLock = <span class="keyword">new</span> PageLock();</span><br><span class="line">    reentrantLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      pages.putIfAbsent(pid, cur);</span><br><span class="line">      lru.add(<span class="number">0</span>, pid);</span><br><span class="line">      pageLockMap.putIfAbsent(pid, pageLock);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      reentrantLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (perm == Permissions.READ_ONLY) &#123;</span><br><span class="line">      pageLock.ReadLock(tid);</span><br><span class="line">      logger.info(<span class="string">&quot;get read lock &#123;&#125;&quot;</span>, pageLock);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (perm == Permissions.READ_WRITE) &#123;</span><br><span class="line">      pageLock.WriteLock(tid);</span><br><span class="line">      logger.info(<span class="string">&quot;get write lock &#123;&#125;&quot;</span>, pageLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Releases the lock on a page.</span></span><br><span class="line"><span class="comment">   * Calling this is very risky, and may result in wrong behavior. Think hard</span></span><br><span class="line"><span class="comment">   * about who needs to call this and why, and why they can run the risk of</span></span><br><span class="line"><span class="comment">   * calling it.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> tid the ID of the transaction requesting the unlock</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pid the ID of the page to unlock</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releasePage</span><span class="params">(TransactionId tid, PageId pid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for proj1</span></span><br><span class="line">    pageLockMap.get(pid).releaseLock(tid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Release all locks associated with a given transaction.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> tid the ID of the transaction requesting the unlock</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionComplete</span><span class="params">(TransactionId tid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for proj1</span></span><br><span class="line">    transactionComplete(tid, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return true if the specified transaction has a lock on the specified page</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">holdsLock</span><span class="params">(TransactionId tid, PageId p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for proj1</span></span><br><span class="line">    <span class="keyword">if</span> (!pageLockMap.containsKey(p)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pageLockMap.get(p).hasLock(tid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a tuple to the specified table behalf of transaction tid.  Will</span></span><br><span class="line"><span class="comment">   * acquire a write lock on the page the tuple is added to(Lock</span></span><br><span class="line"><span class="comment">   * acquisition is not needed for lab2). May block if the lock cannot</span></span><br><span class="line"><span class="comment">   * be acquired.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Marks any pages that were dirtied by the operation as dirty by calling</span></span><br><span class="line"><span class="comment">   * their markDirty bit, and updates cached versions of any pages that have</span></span><br><span class="line"><span class="comment">   * been dirtied so that future requests see up-to-date pages.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> tid     the transaction adding the tuple</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> tableId the table to add the tuple to</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> t       the tuple to add</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTuple</span><span class="params">(TransactionId tid, <span class="keyword">int</span> tableId, Tuple t)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for proj1</span></span><br><span class="line">    Page page = getPage(tid, t.getRecordId().getPageId(), Permissions.READ_WRITE);</span><br><span class="line">    page.markDirty(<span class="keyword">true</span>, tid);</span><br><span class="line">    HeapPage heapPage = (HeapPage) page;</span><br><span class="line">    heapPage.insertTuple(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove the specified tuple from the buffer pool.</span></span><br><span class="line"><span class="comment">   * Will acquire a write lock on the page the tuple is removed from. May block if</span></span><br><span class="line"><span class="comment">   * the lock cannot be acquired.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Marks any pages that were dirtied by the operation as dirty by calling</span></span><br><span class="line"><span class="comment">   * their markDirty bit.  Does not need to update cached versions of any pages that have</span></span><br><span class="line"><span class="comment">   * been dirtied, as it is not possible that a new page was created during the deletion</span></span><br><span class="line"><span class="comment">   * (note difference from addTuple).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> tid the transaction adding the tuple.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> t   the tuple to add</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTuple</span><span class="params">(TransactionId tid, Tuple t)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for proj1</span></span><br><span class="line">    Page page = getPage(tid, t.getRecordId().getPageId(), Permissions.READ_WRITE);</span><br><span class="line">    page.markDirty(<span class="keyword">true</span>, tid);</span><br><span class="line">    HeapPage heapPage = (HeapPage) page;</span><br><span class="line">    heapPage.deleteTuple(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Flush all dirty pages to disk.</span></span><br><span class="line"><span class="comment">   * NB: Be careful using this routine -- it writes dirty data to disk so will</span></span><br><span class="line"><span class="comment">   * break simpledb if running in NO STEAL mode.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flushAllPages</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for proj1</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;PageId, Page&gt; entry : pages.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.getValue().isDirty() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        flushPage(entry.getKey());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove the specific page id from the buffer pool.</span></span><br><span class="line"><span class="comment">   * Needed by the recovery manager to ensure that the</span></span><br><span class="line"><span class="comment">   * buffer pool doesn&#x27;t keep a rolled back page in its</span></span><br><span class="line"><span class="comment">   * cache.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">discardPage</span><span class="params">(PageId pid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for proj1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Flushes a certain page to disk</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pid an ID indicating the page to flush</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flushPage</span><span class="params">(PageId pid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for proj1</span></span><br><span class="line">    logger.info(<span class="string">&quot;flush page &quot;</span> + pid);</span><br><span class="line">    <span class="keyword">if</span> (pages.containsKey(pid)) &#123;</span><br><span class="line">      Page page = pages.get(pid);</span><br><span class="line">      Database.getCatalog().getDbFile(pid.getTableId()).writePage(page);</span><br><span class="line">      page.markDirty(<span class="keyword">false</span>, tid);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Write all pages of the specified transaction to disk.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flushPages</span><span class="params">(TransactionId tid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for proj1</span></span><br><span class="line">    logger.info(<span class="string">&quot;flush begin&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.tid = tid;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;PageId, Page&gt; entry : pages.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.getValue().isDirty() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        flushPage(entry.getKey());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">&quot;flush after&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="NO-STEAL-amp-FORCE"><a href="#NO-STEAL-amp-FORCE" class="headerlink" title="NO STEAL&amp;FORCE"></a>NO STEAL&amp;FORCE</h2><blockquote>
<ul>
<li><p>You shouldn’t evict dirty (updated) pages from the buffer pool if they are locked by an uncommitted transaction (this is NO STEAL).</p>
</li>
<li><p>On transaction commit, you should force dirty pages to disk (e.g., write the pages out) (this is FORCE).</p>
</li>
</ul>
</blockquote>
<h3 id="No-Steal"><a href="#No-Steal" class="headerlink" title="No Steal"></a>No Steal</h3><p>LRU算法实现是使用一个链表的方式来实现的，即每次淘汰都是从列表尾进行淘汰页，不论是否该页还在被使用。为了保证事务的性质，需要改造下：</p>
<ol>
<li>还是从链表尾往前开始遍历，当发现某页没有被事务锁住时才会被替换掉</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Discards a page from the buffer pool.</span></span><br><span class="line"><span class="comment">   * Flushes the page to disk to ensure dirty pages are updated on disk.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">evictPage</span><span class="params">()</span> <span class="keyword">throws</span> DbException </span>&#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for proj1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lru.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      PageId old = lru.get(i);</span><br><span class="line">      <span class="keyword">if</span> (pages.get(old).isDirty() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          lru.remove(i);</span><br><span class="line">          pages.remove(old);</span><br><span class="line">          pageLockMap.remove(old);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="FORCE"><a href="#FORCE" class="headerlink" title="FORCE"></a>FORCE</h3><p>当事务结束时，通知BufferPool。</p>
<p>BufferPool需要根据事务是提交还是终止来处理内存中Page的内容。</p>
<ul>
<li>对于提交的事务，需要将当前事务修改过的page持久化到磁盘中，并释放对应的所有锁。</li>
<li>对于终止的事务，需要将当前事务修改过的page回滚到修改前的版本，并释放对应的所有锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Commit or abort a given transaction; release all locks associated to</span></span><br><span class="line"><span class="comment">  * the transaction.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> tid    the ID of the transaction requesting the unlock</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> commit a flag indicating whether we should commit or abort</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionComplete</span><span class="params">(TransactionId tid, <span class="keyword">boolean</span> commit)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="comment">// some code goes here</span></span><br><span class="line">   <span class="comment">// not necessary for proj1</span></span><br><span class="line">   logger.info(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, tid, commit);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (commit) &#123;</span><br><span class="line">     <span class="keyword">for</span> (PageId pageid : lru) &#123;</span><br><span class="line">       Page page = pages.get(pageid);</span><br><span class="line">       <span class="keyword">if</span> (page.isDirty() != <span class="keyword">null</span> &amp;&amp; page.isDirty() == tid) &#123;</span><br><span class="line">         flushPage(pageid);</span><br><span class="line">       &#125;</span><br><span class="line">       pageLockMap.get(pageid).releaseLock(tid);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (PageId pageid : lru) &#123;</span><br><span class="line">       Page page = pages.get(pageid);</span><br><span class="line">       <span class="keyword">if</span> (page.isDirty() != <span class="keyword">null</span> &amp;&amp; page.isDirty() == tid) &#123;</span><br><span class="line">         pages.put(pageid, page.getBeforeImage());</span><br><span class="line">       &#125;</span><br><span class="line">       pageLockMap.get(pageid).releaseLock(tid);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="死锁检索和处理"><a href="#死锁检索和处理" class="headerlink" title="死锁检索和处理"></a>死锁检索和处理</h2><p>通过给锁加上超时机制来避免死锁。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>事务的ACID四个属性，其中隔离性是比较关键的属性，保证执行不会产生错乱</li>
<li>隔离性有多种实现方式，通常有三种：基于锁机制、基于时间戳机制、MVCC机制</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://sites.google.com/site/cs186fall2013/homeworks/proj4">CS186 Project 4: SimpleDB Transactions</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43493165">深入理解数据库事务</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66737716">数据库事务的四大特性以及事务的隔离级别</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1408793">深入学习MySQL事务：ACID特性的实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/teJA7X43BO2alp6rLCWk">数据库内核杂谈 (十)：事务、隔离、并发（1）</a></li>
</ol>
<!-- flag of hidden posts -->
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/database/" rel="tag"># database</a>
              <a href="/tags/simpleDB/" rel="tag"># simpleDB</a>
          </div>

        

    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason Chao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
