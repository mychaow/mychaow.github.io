<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="SQL计算引擎火山模型（迭代模型）下面介绍的只是执行逻辑，不涉及到计划优化。 基本模型该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，查询树自顶向下的调用next()接口，数据则自底向上的被拉取处理。 Operator一般定义如下： 123456class Operator &amp;#123;        Row next();">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库simpleDB入门-2">
<meta property="og:url" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/index.html">
<meta property="og:site_name" content="我住8楼">
<meta property="og:description" content="SQL计算引擎火山模型（迭代模型）下面介绍的只是执行逻辑，不涉及到计划优化。 基本模型该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，查询树自顶向下的调用next()接口，数据则自底向上的被拉取处理。 Operator一般定义如下： 123456class Operator &amp;#123;        Row next();">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/v2-6746dfcdc105ed4aeea21430406f535c_1440w.jpg">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/v2-25339e28863dbd154954b6f094f8c54f_1440w.jpg">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/0.jpeg">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16410251603691.png">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/1415006-20200718192156170-1831208496.png">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/v2-61f5f7ddbe3801adf7683064381fab77_1440w.jpg">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/image-20220101164427370.png">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/image-20220101165209820.png">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/image-20220101165021903.png">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/f9yy7c787c74d9d5ca216959d9b4a49a.jpg">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/121220102841411.png">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/v2-a7799e5a837bac535113812bd06aac75_1440w.jpg">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/webp.webp">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/605d66fb6b599.jpg">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/b0535a047b5b6d49cb2e46d0cfc742ad.jpeg">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/b3de1a83cc126b651809af6d473ccd90.jpeg">
<meta property="og:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/640.png">
<meta property="article:published_time" content="2021-12-27T10:57:57.000Z">
<meta property="article:modified_time" content="2022-01-02T09:04:11.940Z">
<meta property="article:author" content="Jason Chao">
<meta property="article:tag" content="database">
<meta property="article:tag" content="simpleDB">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/v2-6746dfcdc105ed4aeea21430406f535c_1440w.jpg">


<link rel="canonical" href="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>数据库simpleDB入门-2 | 我住8楼</title><meta name="robots" content="noindex">
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我住8楼</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E"><span class="nav-number">1.</span> <span class="nav-text">SQL计算引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%81%AB%E5%B1%B1%E6%A8%A1%E5%9E%8B%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">火山模型（迭代模型）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">基本模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96"><span class="nav-number">1.1.2.</span> <span class="nav-text">优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E5%8C%96"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">向量化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">代码生成</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">计算模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MR%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">MR计算模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MR%E6%A8%A1%E5%9E%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">2.1.1.</span> <span class="nav-text">MR模型说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hive%EF%BC%88SQL-on-hadoop%EF%BC%89"><span class="nav-number">2.1.2.</span> <span class="nav-text">Hive（SQL on hadoop）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DAG%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">DAG计算模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TEZ"><span class="nav-number">2.2.1.</span> <span class="nav-text">TEZ</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DAG"><span class="nav-number">2.2.1.2.1.</span> <span class="nav-text">DAG</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E7%BB%84%E4%BB%B6"><span class="nav-number">2.2.1.2.2.</span> <span class="nav-text">编程组件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spark"><span class="nav-number">2.2.2.</span> <span class="nav-text">Spark</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDD"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">RDD</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD%E7%9A%84%E7%AE%97%E5%AD%90%E5%88%86%E7%B1%BB"><span class="nav-number">2.2.2.1.1.</span> <span class="nav-text">RDD的算子分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD%E4%BE%9D%E8%B5%96"><span class="nav-number">2.2.2.1.2.</span> <span class="nav-text">RDD依赖</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DAGScheduler"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">DAGScheduler</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MPP%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text">MPP计算模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="nav-number">2.3.1.</span> <span class="nav-text">服务器架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SMP"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">SMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NUMA"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">NUMA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MPP"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">MPP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MPP%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">MPP计算模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MPP%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">MPP的设计缺陷</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E4%BB%93%E6%9E%B6%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">数仓架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E5%AD%90"><span class="nav-number">4.</span> <span class="nav-text">算子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E5%AD%90"><span class="nav-number">4.1.</span> <span class="nav-text">扫描算子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#indexscan-%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F"><span class="nav-number">4.1.1.</span> <span class="nav-text">indexscan 索引扫描</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tablescan-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="nav-number">4.1.2.</span> <span class="nav-text">tablescan 顺序表扫描</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E7%AE%97%E5%AD%90"><span class="nav-number">4.2.</span> <span class="nav-text">过滤算子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#project-%E6%8A%95%E5%BD%B1"><span class="nav-number">4.2.1.</span> <span class="nav-text">project 投影</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter-%E8%BF%87%E6%BB%A4"><span class="nav-number">4.2.2.</span> <span class="nav-text">filter 过滤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E7%AE%97%E5%AD%90"><span class="nav-number">4.3.</span> <span class="nav-text">交换算子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exchange"><span class="nav-number">4.3.1.</span> <span class="nav-text">exchange</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join-%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.3.2.</span> <span class="nav-text">join 连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E7%AE%97%E5%AD%90"><span class="nav-number">4.4.</span> <span class="nav-text">计算算子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#aggregation-%E8%81%9A%E5%90%88"><span class="nav-number">4.4.1.</span> <span class="nav-text">aggregation 聚合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#values"><span class="nav-number">4.4.2.</span> <span class="nav-text">values</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scalar-%E6%A0%87%E9%87%8F"><span class="nav-number">4.4.3.</span> <span class="nav-text">scalar 标量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#markDistinct"><span class="nav-number">4.4.4.</span> <span class="nav-text">markDistinct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window-%E7%AA%97%E5%8F%A3"><span class="nav-number">4.4.5.</span> <span class="nav-text">window 窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-%E6%8E%92%E5%BA%8F"><span class="nav-number">4.4.6.</span> <span class="nav-text">sort 排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#topn"><span class="nav-number">4.4.7.</span> <span class="nav-text">topn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#output"><span class="nav-number">4.4.8.</span> <span class="nav-text">output</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lab2"><span class="nav-number">5.</span> <span class="nav-text">lab2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DbIterator-amp-Operator"><span class="nav-number">5.1.</span> <span class="nav-text">DbIterator&amp;Operator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DbIterator"><span class="nav-number">5.1.1.</span> <span class="nav-text">DbIterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Operator"><span class="nav-number">5.1.2.</span> <span class="nav-text">Operator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Filter-amp-Join"><span class="nav-number">5.2.</span> <span class="nav-text">Filter&amp;Join</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Predicate"><span class="nav-number">5.2.1.</span> <span class="nav-text">Predicate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JoinPredicate"><span class="nav-number">5.2.2.</span> <span class="nav-text">JoinPredicate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Filter%E7%AE%97%E5%AD%90"><span class="nav-number">5.2.3.</span> <span class="nav-text">Filter算子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Join%E7%AE%97%E5%AD%90"><span class="nav-number">5.2.4.</span> <span class="nav-text">Join算子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Aggregation"><span class="nav-number">5.3.</span> <span class="nav-text">Aggregation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IntegerAggregator-amp-StringAggregator-amp-Aggregate"><span class="nav-number">5.3.1.</span> <span class="nav-text">IntegerAggregator&amp;StringAggregator&amp;Aggregate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IntegerAggregator"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">IntegerAggregator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringAggregator"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">StringAggregator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Aggregate"><span class="nav-number">5.3.1.3.</span> <span class="nav-text">Aggregate</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Insert-amp-Delete"><span class="nav-number">5.4.</span> <span class="nav-text">Insert&amp;Delete</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#insert"><span class="nav-number">5.4.1.</span> <span class="nav-text">insert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Delete"><span class="nav-number">5.4.2.</span> <span class="nav-text">Delete</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page%E7%BD%AE%E6%8D%A2"><span class="nav-number">5.5.</span> <span class="nav-text">Page置换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason Chao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason Chao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我住8楼">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库simpleDB入门-2
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-27 18:57:57" itemprop="dateCreated datePublished" datetime="2021-12-27T18:57:57+08:00">2021-12-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-02 17:04:11" itemprop="dateModified" datetime="2022-01-02T17:04:11+08:00">2022-01-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="SQL计算引擎"><a href="#SQL计算引擎" class="headerlink" title="SQL计算引擎"></a>SQL计算引擎</h1><h2 id="火山模型（迭代模型）"><a href="#火山模型（迭代模型）" class="headerlink" title="火山模型（迭代模型）"></a>火山模型（迭代模型）</h2><p>下面介绍的只是执行逻辑，不涉及到计划优化。</p>
<h3 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h3><p>该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，查询树自顶向下的调用next()接口，数据则自底向上的被拉取处理。</p>
<p>Operator一般定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operator</span> &#123;</span></span><br><span class="line">        <span class="function">Row <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">        Operator children[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在具体的 operator 中一般包含其需要计算的 expression，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Projection</span> <span class="title">extends</span> <span class="title">Operator</span> &#123;</span></span><br><span class="line">        Expression projectionExprs[];</span><br><span class="line">        <span class="function">Row <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Row output = <span class="keyword">new</span> Row(projectionExprs.length);</span><br><span class="line">                Row input = children[<span class="number">0</span>].next();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; projectionExprs.length; i++) &#123;</span><br><span class="line">                        output.<span class="built_in">set</span>(i, projectionExprs[i].eval(input));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示，每个算子从子算子获取记录，然后加上自己的运算后吐出给上层算子。</p>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/v2-6746dfcdc105ed4aeea21430406f535c_1440w.jpg" class="" title="img">

<p>火山模型的最大好处是实现简单，每个 operator 都只需要完成其自身特定的功能，operator 之间是完全解耦合的，SQL complier 只需要根据 SQL 的逻辑构造对应的 operator 然后将 operator 串联起来即可。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面这套模型诞生于上世纪九十年代，对于那时候的数据库产品，IO 速度是远小于计算速度的，所以计算引擎上的提速对整体数据库的提速效果并不多，大部分数据库优化更偏向于怎么更快的读取数据，但是随着近年来数据库存储组件越来越快，数据库从业者们发现计算速度也逐渐成为了数据库的一个瓶颈。</p>
<p>火上模型每次计算都会有多次虚函数调用：</p>
<ol>
<li>算子的next调用</li>
<li>表达式的eval调用</li>
</ol>
<p>虚函数不仅有开销，而且影响编译器对其进行优化。</p>
<p>从上面的介绍来看，经典 SQL 的计算引擎一个很大问题就是无论是 expression 还是 operator ，其计算的时候都大量使用到虚函数，由于每行数据都需要经过这一系列的运算，导致计算框架开销比较大，而且由于虚函数的大量使用，也影响了编译器的优化空间。在减小框架开销方面，两个常用的方法就是</p>
<ul>
<li>均摊开销</li>
<li>消除开销</li>
</ul>
<h4 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h4><p>向量化执行的思想就是均摊开销：</p>
<ol>
<li>假设每次通过 operator tree 生成一行结果的开销是 C 的话，经典模型的计算框架总开销就是 C * N，其中 N 为参与计算的总行数，如果把计算引擎每次生成一行数据的模型改为每次生成一批数据的话，因为每次调用的开销是相对恒定的，所以计算框架的总开销就可以减小到C * N / M，其中 M 是每批数据的行数，这样每一行的开销就减小为原来的 1 / M，当 M 比较大时，计算框架的开销就不会成为系统瓶颈了。</li>
<li>除此之外，向量化执行还能给 compiler 带来更多的优化空间，因为引入向量化之后，实际上是将原来数据库运行时的一个大 for 循环拆成了两层 for 循环，内层的 for 循环通常会比较简单，对编译器来说也存在更大的优化可能性。</li>
</ol>
<p>举例来说，对于一个实现两个 int 相加的 expression，在向量化之前，其实现可能是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpressionIntAdd</span> <span class="title">extends</span> <span class="title">Expression</span> &#123;</span></span><br><span class="line">        <span class="function">Datum <span class="title">eval</span><span class="params">(Row input)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> left = input.getInt(leftIndex);</span><br><span class="line">                <span class="keyword">int</span> right = input.getInt(rightIndex);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Datum(left+right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在向量化之后，其实现可能会变为这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VectorExpressionIntAdd</span> <span class="title">extends</span> <span class="title">VectorExpression</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span>[] eval(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[input.length];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">                        ret[i] = <span class="keyword">new</span> Datum(left[i] + right[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然对比向量化之前的版本，向量化之后的版本不再是每次只处理一条数据，而是每次能处理一批数据，而且这种向量化的计算模式在计算过程中也具有更好的数据局部性。</p>
<h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>代码生成的思想是消除开销。</p>
<p>代码生成可以在两个层面上进行，一个是 expression 层面，一个是 operator 层面，当然也可以同时在 expression 与 operator 层面进行代码生成。经典 SQL 计算引擎的一大缺点就是各种虚函数调用不但会带来很多额外的开销，而且还挤压了 compiler 的优化空间。</p>
<p>代码生成可以直观的理解为在 SQL plan build 好之后，将 plan 中的代码进行一次逻辑上的内联。如果实现的好，代码生成能够将上述所说的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/write#anchor">火山模型代码</a>转换为类似于<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/write#anchor2">手动优化的代码</a>，显然和向量化执行一样，代码生成后的新代码也给编译器带来了更多的优化机会。</p>
<p>与向量化执行相比，代码生成之后数据库运行时仍然是一个 for 循环，只不过这个循环内部的代码从简单的一个虚函数调用<code>plan.next()</code>展开成了一系列具体的运算逻辑，这样数据就不用再各个 operator 之间进行传递，而且有些数据还可以直接被存放在寄存器中，进一步提升系统性能。</p>
<p>当然为了获取这些好处代码生成也付出了一定的代价，代码生成需要在 SQL 编译器编译获得 plan 之后进行额外的 code gen + jit ，对应到具体的工程实现也比向量化执行的难度要高一些。 </p>
<p>举例来说，对于下面这条 query:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from R1,</span><br><span class="line">    (select R2.y, count(*)</span><br><span class="line">    from R2</span><br><span class="line">    where R2.x=3</span><br><span class="line">    group by R2.y) R2</span><br><span class="line">where R1.a=7 and R1.b=R2.y</span><br></pre></td></tr></table></figure>
<p>通过代码生成技术，其执行过程会变成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;Row&gt;&gt; hash_table_for_join;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash_table_for_agg;</span><br><span class="line"><span class="keyword">for</span>(Row row in scanBuffer_R1) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = row.getInt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> b = row.getInt(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">7</span>) &#123;</span><br><span class="line">                <span class="comment">// ignore the case when the key `b` doesn&#x27;t exists for simplicity</span></span><br><span class="line">                hash_table_for_join[b].push_back(row);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Row row in scanBuffer_R2) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = row.getInt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> y = row.getInt(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// ignore the case when the key `y` doesn&#x27;t exists for simplicity</span></span><br><span class="line">                hash_table_for_agg[y] = hash_table_for_agg[y] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v1 : hash_table_for_agg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v2 : hash_table_for_join) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1.first == v2.first) &#123;</span><br><span class="line">                        <span class="comment">// construct new row and send to the client</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比于传统的火山模型，上述执行过程不再以 operator 为核心，而是以数据为核心，其最大特征是将单一 operator 的执行逻辑分散在多个代码块中，模糊了 operator 之间的执行边界，从而大大降低了 operator 之间数据传递的开销。</p>
<h1 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h1><h2 id="MR计算模型"><a href="#MR计算模型" class="headerlink" title="MR计算模型"></a>MR计算模型</h2><h3 id="MR模型说明"><a href="#MR模型说明" class="headerlink" title="MR模型说明"></a>MR模型说明</h3><p>MapReduce最早是由Google公司研究提出的一种面向大规模数据处理的并行计算模型和方法。Google公司设计MapReduce的初衷，主要是为了解决其搜索引擎中大规模网页数据的并行化处理。</p>
<p>   Google公司发明了MapReduce之后，首先用其重新改写了其搜索引擎中的Web文档索引处理系统。但由于MapReduce可以普遍应用于很多大规模数据的计算问题，因此自发明MapReduce以后，Google公司内部进一步将其广泛应用于很多大规模数据处理问题。到目前为止，Google公司内有上万个各种不同的算法问题和程序都使用MapReduce进行处理。</p>
<p>如下图所示，MapReduce 分为 Map 和 Reduce 两个核心阶段，其中 Map 对应“分”，即把复杂的任务分解为若干个“简单的任务”执行；Reduce 对应着“合”，即对 Map 阶段的结果进行汇总。</p>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/v2-25339e28863dbd154954b6f094f8c54f_1440w.jpg" class="" title="img">

<p><strong>在第一阶段</strong>，也就是 Map 阶段，将大数据计算任务拆分为多个子任务，拆分后的子任务通常具有如下特征：</p>
<p>相对于原始任务来说，划分后的子任务与原任务是同质的，比如原任务是统计全国人口数，拆分为统计省的人口数子任务时，都是统计人口数；</p>
<p>并且，子任务的数据规模和计算规模会小很多。多个子任务之间没有依赖，可以独立运行、并行计算，比如按照省统计人口数，统计河北省的人口数和统计湖南省的人口数之间没有依赖关系，可以独立、并行地统计。</p>
<p><strong>第二阶段</strong>，也就是 Reduce 阶段，第一阶段拆分的子任务计算完成后，汇总所有子任务的计算结果，以得到最终结果。也就是，汇总各个省统计的人口数，得到全国的总人口数。</p>
<h3 id="Hive（SQL-on-hadoop）"><a href="#Hive（SQL-on-hadoop）" class="headerlink" title="Hive（SQL on hadoop）"></a>Hive（SQL on hadoop）</h3><p>下图是hive执行流程，hive将sql拆成MapReduce任务，运行完成后返回结果给用户。</p>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/0.jpeg" class="" title="img">

<h2 id="DAG计算模型"><a href="#DAG计算模型" class="headerlink" title="DAG计算模型"></a>DAG计算模型</h2><h3 id="TEZ"><a href="#TEZ" class="headerlink" title="TEZ"></a>TEZ</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>MR性能差，资源消耗大，如：Hive作业之间的数据不是直接流动的，而是借助HDFS作为共享数据存储系统，即一个作业将处理好的数据写入HDFS，下一个作业再从HDFS重新读取数据进行处理。很明显更高效的方式是，第一个作业直接将数据传递给下游作业。</p>
<p>MR 默认了map和reduce阶段，map会对中间结果进行分区、排序，reduce会进行合并排序，这一过程并不适用于所有场景。</p>
<p>引擎级别的Runtime优化：MR执行计划在编译时已经确定，无法动态调整(?)。然而在执行ETL和Ad-hoc等任务时，根据实际处理的表大小，动态调整join策略、任务并行度将大大缩短任务执行时间。</p>
<p>下面给您展示一张Tez官方图，您就可以简单明白Tez和MapReduce的关系。</p>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16410251603691.png" class="" title="img">

<p><strong>核心思想</strong>：将Map任务和Reduce任务进一步拆分，Map任务拆分为Input-Processor-Sort-Merge-Output，Reduce任务拆分为Input-Shuffer-Sort-Merge-Process-output，Tez将若干小任务灵活重组，形成一个大的DAG作业。</p>
<blockquote>
<p>Tez与oozie不同：oozie只能以MR任务为整体来管理、组织，本质上仍然是多个MR任务的执行，不能解决上面提到的多个任务之间硬盘IO冗余的问题。</p>
</blockquote>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Tez包含的组件：</p>
<ul>
<li><p>有向无环图（DAG）——定义整体任务。一个DAG对象对应一个任务。</p>
</li>
<li><p>节点（Vertex）——定义用户逻辑以及执行用户逻辑所需的资源和环境。一个节点对应任务中的一个步骤。</p>
</li>
<li><p>边（Edge）——定义生产者和消费者节点之间的连接。</p>
</li>
</ul>
<p>边需要分配属性，对Tez而言这些属性是必须的，有了它们才能在运行时将逻辑图展开为能够在集群上并行执行的物理任务集合。下面是一些这样的属性：</p>
<ul>
<li><p>数据移动属性，定义了数据如何从一个生产者移动到一个消费者。</p>
</li>
<li><p>调度（Scheduling）属性（顺序或者并行），帮助我们定义生产者和消费者任务之间应该在什么时候进行调度。</p>
</li>
<li><p>数据源属性（持久的，可靠的或者暂时的），定义任务输出内容的生命周期或者持久性，让我们能够决定何时终止。</p>
</li>
</ul>
<p>该模型所有的输入和输出都是可插拔的。为了方便，Tez使用了一个基于事件的模型，目的是为了让任务和系统之间、组件和组件之间能够通信。事件用于将信息（例如任务失败信息）传递给所需的组件，将输出的数据流（例如生成的数据位置信息）传送给输入，以及在运行时对DAG执行计划做出改变等。Tez还提供了各种开箱即用的输入和输出处理器。这些富有表现力的API能够让更高级语言（例如Hive）的编写者很优雅地将自己的查询转换成Tez任务。</p>
<h5 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h5><p>Edge：定义了上下游Vertex之间的连接方式。</p>
<p>Edge相关属性：</p>
<ul>
<li>Data movement：定义了producer与consumer之间数据流动的方式。<ul>
<li>One-To-One: 第i个producer产生的数据，发送给第i个consumer。这种上下游关系属于Spark的窄依赖。</li>
<li>Broadcast: producer产生的数据路由都下游所有consumer。这种上下游关系也属于Spark的窄依赖。</li>
<li>Scatter-Gather: producer将产生的数据分块，将第i块数据发送到第i个consumer。这种上下游关系属于Spark的宽依赖。</li>
</ul>
</li>
</ul>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/1415006-20200718192156170-1831208496.png" class="" title="wxmp">

<ul>
<li>Scheduling：定义了何时启动consumer Task<ul>
<li>Sequential: Consumer task 需要producer task结束后启动，如：MR。</li>
<li>Concurrent: Consumer task 与producer task一起启动，如：流计算。</li>
</ul>
</li>
<li>Data source：定义了任务output的生命周期与可靠性。<ul>
<li>Persisted: 当任务退出后，该任务output依然存在，但经过一段时间后，可能会被删除，如：Mapper输出的中间结果。</li>
<li>Persisted-Reliable: 任务output总是存在，比如，MR中reducer的输出结果，存在HDFS上。</li>
<li>Ephemeral: 任务输出只有当该task在运行的时候，才存在，如：流计算的中间结果。</li>
</ul>
</li>
</ul>
<p>任务从逻辑DAG到最后物理执行计划示意图：</p>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/v2-61f5f7ddbe3801adf7683064381fab77_1440w.jpg" class="" title="img">

<h5 id="编程组件"><a href="#编程组件" class="headerlink" title="编程组件"></a>编程组件</h5><p>Tez对外提供了6种可编程组件，分别是：</p>
<ul>
<li><p>Input：对输入数据源的抽象，它解析输入数据格式，并吐出一个个Key/value</p>
</li>
<li><p>Output：对输出数据源的抽象，它将用户程序产生的Key/value写入文件系统</p>
</li>
<li><p>Paritioner：对数据进行分片，类似于MR中的Partitioner</p>
</li>
<li><p>Processor：对计算的抽象，它从一个Input中获取数据，经处理后，通过Output输出</p>
</li>
<li><p>Task：对任务的抽象，每个Task由一个Input、Ouput和Processor组成</p>
</li>
<li><p>Maser ：管理各个Task的依赖关系，并按顺依赖关系执行他们</p>
</li>
</ul>
<p>除了以上6种组件，Tez还提供了两种算子，分别是Sort（排序）和Shuffle（混洗），为了用户使用方便，它还提供了多种Input、Output、Task和Sort的实现。</p>
<p>下面是运行时API：</p>
<ul>
<li><p>Input: 接收上游Output事件，获取上游数据位置；从physical Edge中获取实际数据；解析实际数据，为Processor提供统一的逻辑试图；</p>
</li>
<li><p>Processor: 利用Input获取实际数据，执行用户逻辑，最后输出；</p>
</li>
<li><p>Output: 将Processor提供的数据，进行分区；向下游Input发送事件；</p>
</li>
<li><p>Tez的事件驱动机制: Tez中各个组件通过不同类型的Event进行通信。</p>
</li>
<li><ul>
<li>数据传输：Output通过ShuffleEvent传递上游数据位置，AM负责将Event路由到相应Input中。</li>
<li>容错：Input当无法获取到上游数据时，会通知框架重新调度上游任务，这也意味着任务成功完成后，仍然会被重新调度。</li>
<li>runtime执行计划优化：根据上游Map Stage产生的数据大小，动态reducer并行度。Output产生的事件路由到可拔插的Vertex/Edge management module，对应moudule就可以对runtime执行计划进行调整。</li>
</ul>
</li>
<li><img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/image-20220101164427370.png" class="" title="image-20220101164427370">

</li>
</ul>
<p>对于运行时优化，在任务运行时，程序知晓更多任务相关的信息，通过这些信息，我们可以动态修改修改执行计划，比如：修改mapper或reducer数量，决定何时启动reducer等。在Tez中，不同组件通过不同事件类型，进行通信。</p>
<ul>
<li>动态修改reducer并行度：MapTask通过VertexManager类型的事件向ShuffleVertextManager发送信息，比如:所处理的partition大小等。 ShuffleVertexManager通过所获得的信息，可以估算出所有Task的输出数据大小，最后来调整下游reduce Vertex的并行度，如下俩图：</li>
</ul>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/image-20220101165209820.png" class="" title="image-20220101165209820">



<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/image-20220101165021903.png" class="" title="image-20220101165021903">

<h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><h4 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h4><p>RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将数据缓存在内存中，后续的查询能够重用这些数据，这极大地提升了查询速度。</p>
<ul>
<li>Resilient：RDD中的数据可以存储在<strong>内存中或者磁盘中</strong>。　</li>
<li>Distributed：RDD中的数据是<strong>分布式存储</strong>的，可用于分布式计算。</li>
<li>Dataset：一个<strong>数据集合</strong>，用于存放数据的。</li>
</ul>
<p>为了弄清楚 RDD 的基本构成和特性，我们从它的 5 大核心属性说起。</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">成员类型</th>
<th align="center">属性含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">dependencies</td>
<td align="center">变量</td>
<td align="center">生成该RDD所依赖的父RDD</td>
</tr>
<tr>
<td align="center">compute</td>
<td align="center">方法</td>
<td align="center">生成该RDD的计算接口</td>
</tr>
<tr>
<td align="center">partitions</td>
<td align="center">变量</td>
<td align="center">该RDD的所有数据分片实体</td>
</tr>
<tr>
<td align="center">partitioner</td>
<td align="center">方法</td>
<td align="center">划分数据分片的规则</td>
</tr>
<tr>
<td align="center">preferredLocations</td>
<td align="center">变量</td>
<td align="center">数据分片的物理位置偏好</td>
</tr>
</tbody></table>
<p>对于 RDD 数据模型的抽象，我们只需关注前两个属性，即 dependencies 和 compute。任何一个 RDD 都不是凭空产生的，每个 RDD 都是基于一定的“计算规则”从某个“数据源”转换而来。dependencies 指定了生成该 RDD 所需的“数据源”，术语叫作依赖或父 RDD；compute 描述了从父 RDD 经过怎样的“计算规则”得到当前的 RDD。这两个属性看似简单，实则大有智慧。</p>
<p>与 MapReduce 以算子（Map 和 Reduce）为第一视角、以外部数据为衔接的设计方式不同，Spark Core 中 RDD 的设计以数据作为第一视角，不再强调算子的重要性，算子仅仅是 RDD 数据转换的一种计算规则，map 算子和 reduce 算子纷纷被弱化、稀释在 Spark 提供的茫茫算子集合之中。dependencies 与 compute 两个核心属性实际上抽象出了“从哪个数据源经过怎样的计算规则和转换，从而得到当前的数据集”。父与子的关系是相对的，将思维延伸，如果当前 RDD 还有子 RDD，那么从当前 RDD 的视角看过去，子 RDD 的 dependencies 与 compute 则描述了“从当前 RDD 出发，再经过怎样的计算规则与转换，可以获得新的数据集”。</p>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/f9yy7c787c74d9d5ca216959d9b4a49a.jpg" class="" title="img">



<p>不难发现，所有 RDD 根据 dependencies 中指定的依赖关系和 compute 定义的计算逻辑构成了一条从起点到终点的数据转换路径。这条路径在 Spark 中有个专门的术语，叫作 Lineage —— 血统。Spark Core 依赖血统进行依赖管理、阶段划分、任务分发、失败重试，任意一个 Spark 计算作业都可以析构为一个 Spark Core 血统。关于血统，到后文书再展开讨论，我们继续介绍 RDD 抽象的另外 3 个属性，即 partitions、partitioner 和 preferredLocations。相比 dependencies 和 compute 属性，这 3 个属性更“务实”一些。</p>
<p>在分布式计算中，一个 RDD 抽象可以对应多个数据分片实体，所有数据分片构成了完整的 RDD 数据集。partitions 属性记录了 RDD 的每一个数据分片，方便开发者灵活地访问数据集。partitioner 则描述了 RDD 划分数据分片的规则和逻辑，采用不同的 partitioner 对 RDD 进行划分，能够以不同的方式得到不同数量的数据分片。因此，partitioner 的选取，直接决定了 partitions 属性的分布。preferredLocations —— 位置偏好，该属性与 partitions 属性一一对应，定义了每一个数据分片的物理位置偏好。具体来说，每个数据分片可以有以下几种不同的位置偏好：</p>
<ul>
<li>本地内存：数据分片已存储在当前计算节点的内存中，可就地访问</li>
<li>本地磁盘：数据分片在当前计算节点的磁盘中有副本，可就地访问</li>
<li>本机架磁盘：当前节点没有分片副本，但是同机架其他机器的磁盘中有副本</li>
<li>其他机架磁盘：当前机架所有节点都没有副本，但其他机架的机器上有副本</li>
<li>无所谓：当前数据分片没有位置偏好</li>
</ul>
<p>根据“数据不动代码动”的原则，Spark Core 优先尊重数据分片的本地位置偏好，尽可能地将计算任务分发到本地计算节点去处理。显而易见，本地计算的优势来源于网络开销的大幅减少，进而从整体上提升执行性能。</p>
<p>RDD 的 5 大属性从“虚”与“实”两个角度刻画了对数据模型的抽象，任何数据集，无论格式、无论形态，都可以被 RDD 抽象、封装。前面提到，任意分布式计算作业都可以抽象为血统，而血统由不同 RDD 抽象的依次转换构成，因此，任意的分布式作业都可以由 RDD 抽象之间的转换来实现。理论上，如果计算节点内存足够大，那么所有关于 RDD 的转换操作都可以放到内存中来执行，这便是“内存计算”的由来。</p>
<h5 id="RDD的算子分类"><a href="#RDD的算子分类" class="headerlink" title="RDD的算子分类"></a>RDD的算子分类</h5><p>　　Transformation（转换）：根据数据集创建一个新的数据集，计算后返回一个新RDD；例如：一个rdd进行map操作后生了一个新的rdd。</p>
<p>　　Action（动作）：对rdd结果计算后返回一个数值value给驱动程序；</p>
<h5 id="RDD依赖"><a href="#RDD依赖" class="headerlink" title="RDD依赖"></a>RDD依赖</h5><p>窄依赖：子RDD中的每个数据块只依赖于父RDD中对应的有限个固定的数据块，可以理解成父子RDD是一对一或者多对一的关系，例如：map变换，前后的数据都是一行对一行的。一个子RDD可以根据其父RDD直接计算得出，因而子RDD出现计算错误的时候，只需要重新计算对应的父RDD即可</p>
<p>宽依赖：子RDD中的一个数据块可以依赖于父RDD中的所有数据块。即一对多的情况，例如：groupByKey变换，子RDD中的数据块会依赖于多个父RDD中的数据块，因为一个key可能存在于父RDD的任何一个数据块中 。宽依赖中的子RDD要等到所有的父RDD计算完成之后才能进行计算，当数据丢失时需要对所有祖先RDD进行重新计算</p>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/121220102841411.png" class="" title="img">

<p>区分宽窄依赖主要就是看父RDD的一个partition的流向，要是流向一个的话就是窄依赖，流向多个的话就是宽依赖。</p>
<h4 id="DAGScheduler"><a href="#DAGScheduler" class="headerlink" title="DAGScheduler"></a>DAGScheduler</h4><p>DAGScheduler 是 Spark 分布式调度系统的重要组件之一，其他组件还包括 TaskScheduler、MapOutputTracker、SchedulerBackend 等。DAGScheduler 的主要职责是根据 RDD 依赖关系将 DAG 划分为 Stages，以 Stage 为粒度提交任务（TaskSet）并跟踪任务进展。</p>
<p>这个过程如图所示：</p>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/v2-a7799e5a837bac535113812bd06aac75_1440w.jpg" class="" title="img">

<p>具体来说DAGScheduler的功能如下：</p>
<p>1.划分和创建Stage：根据RDD之间的依赖类型（窄依赖或宽依赖），为每个Job划分和创建Stage，多个Stage之间相互依赖，形成一个DAG（有向无环图）。何时切割 DAG 并生成新的 Stage 由 RDD 的依赖类型决定，<strong>当且仅当 RDD 的依赖是 ShuffleDependency 时，DAGScheduler 才会新建 Stage。</strong></p>
<p>2.决定运行Task的最佳位置：根据RDD的依赖关系，缓存或Shuffling数据的位置来计算运行Task的最佳位置。</p>
<p>3.为每个Stage创建一个TaskSet，并把TaskSet作为参数传递给TaskScheduler。</p>
<p>4.处理失败的Stage：为了从失败中恢复，同样的Stage可能会提交多次。例如：由于前一个Stage的map输出文件丢失，TaskScheduler报告了一个任务失败，DAGScheduler会重新提交丢失的Stage。这是通过一个带有FetchFailed或ExecutorLost的CompletionEvent事件检测到的。DAGScheduler将等待一小段时间以查看其他节点或任务是否失败，然后为任何缺失的Stage重新提交TaskSet。</p>
<p>5.当任务运行完成后，清空所有的缓存和临时数据。</p>
<p>6.处理各种事件，包括内部的事件，也包括Executor端的状态更新等事件。</p>
<p>为什么以shuffle来划分stage呢，因为shuffle往往都是性能的瓶颈，有优化空间，因此以此来划分stage，shuffle被单独对待，可以对shuffle做更好的优化。</p>
<p>spark的任务执行过程如下：</p>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/webp.webp" class="" title="img">





<h2 id="MPP计算模型"><a href="#MPP计算模型" class="headerlink" title="MPP计算模型"></a>MPP计算模型</h2><h3 id="服务器架构"><a href="#服务器架构" class="headerlink" title="服务器架构"></a>服务器架构</h3><p>目前商用的服务器分类大体有三种：</p>
<ul>
<li>SMP（对称多处理器结构）</li>
<li>NUMA（非一致存储访问结构）</li>
<li>MPP（大规模并行处理结构）</li>
</ul>
<p>我们今天的主角是 MPP，因为随着分布式、并行化技术成熟应用，MPP引擎逐渐表现出强大的高吞吐、低时延计算能力，有很多采用MPP架构的引擎都能达到“亿级秒开”。</p>
<p>先了解下这三种结构：</p>
<h4 id="SMP"><a href="#SMP" class="headerlink" title="SMP"></a>SMP</h4><p>即对称多处理器结构，就是指服务器的多个CPU对称工作，无主次或从属关系。SMP服务器的主要特征是共享，系统中的所有资源（如CPU、内存、I／O等）都是共享的。也正是由于这种特征，导致了SMP服务器的主要问题，即扩展能力非常有限。实验证明，SMP服务器CPU利用率最好的情况是2至4个CPU。</p>
<h4 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h4><p>即非一致存储访问结构。这种结构就是为了解决SMP扩展能力不足的问题，利用NUMA技术，可以把几十个CPU组合在一台服务器内。NUMA的基本特征是拥有多个CPU模块，节点之间可以通过互联模块进行连接和信息交互，所以，每个CPU可以访问整个系统的内存（这是与MPP系统的重要区别）。但是访问的速度是不一样的，因为CPU访问本地内存的速度远远高于系统内其他节点的内存速度，这也是非一致存储访问NUMA的由来。</p>
<p>这种结构也有一定的缺陷，由于访问异地内存的时延远远超过访问本地内存，因此，当CPU数量增加时，系统性能无法线性增加。</p>
<h4 id="MPP"><a href="#MPP" class="headerlink" title="MPP"></a>MPP</h4><p>即大规模并行处理结构。MPP的系统扩展和NUMA不同，MPP是由多台SMP服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。每个节点只访问自己的资源，所以是一种完全无共享（Share Nothing）结构。</p>
<p>MPP结构扩展能力最强，理论可以无限扩展。由于MPP是多台SMP服务器连接的，每个节点的CPU不能访问另一个节点内存，所以也不存在异地访问的问题。</p>
<p>MPP架构图：</p>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/605d66fb6b599.jpg" class="" title="img">

<p>每个节点内的CPU不能访问另一个节点的内存，节点之间的信息交互是通过节点互联网络实现的，这个过程称为数据重分配。</p>
<p>但是MPP服务器需要一种复杂的机制来调度和平衡各个节点的负载和并行处理过程。目前，一些基于MPP技术的服务器往往通过系统级软件（如数据库）来屏蔽这种复杂性。举个例子，Teradata就是基于MPP技术的一个关系数据库软件（这是最早采用MPP架构的数据库），基于此数据库来开发应用时，不管后台服务器由多少节点组成，开发人员面对的都是同一个数据库系统，而无需考虑如何调度其中某几个节点的负载。</p>
<p>MPP架构特征：</p>
<ul>
<li>任务并行执行；</li>
<li>数据分布式存储（本地化）；</li>
<li>分布式计算；</li>
<li>高并发，单个节点并发能力大于300用户；</li>
<li>横向扩展，支持集群节点的扩容；</li>
<li>Shared Nothing（完全无共享）架构。</li>
</ul>
<blockquote>
<p>NUMA和MPP区别：</p>
<p>二者有许多相似之处，首先NUMA和MPP都是由多个节点组成的；其次每个节点都有自己的CPU，内存，I／O等；都可以都过节点互联机制进行信息交互。</p>
<p>那它们的区别是什么呢:</p>
<ul>
<li><p>首先是节点互联机制不同，NUMA的节点互联是在同一台物理服务器内部实现的，MPP的节点互联是在不同的SMP服务器外部通过I／O实现的。</p>
</li>
<li><p>其次是内存访问机制不同，在NUMA服务器内部，任何一个CPU都可以访问整个系统的内存，但异地内存访问的性能远远低于本地内存访问，因此，在开发应用程序时应该尽量避免异地内存访问。而在MPP服务器中，每个节点只访问本地内存，不存在异地内存访问问题。</p>
</li>
</ul>
</blockquote>
<h3 id="MPP计算模型-1"><a href="#MPP计算模型-1" class="headerlink" title="MPP计算模型"></a>MPP计算模型</h3><ul>
<li><p>MPP解决方案的最原始想法就是<strong>消除共享资源</strong>。每个执行器有单独的CPU，内存和硬盘资源。一个执行器无法直接访问另一个执行器上的资源，除非通过网络上的受控的数据交换。这种资源独立的概念，对于MPP架构来说很完美的解决了<strong>可扩展性</strong>的问题。</p>
</li>
<li><p>MPP的第二个主要概念就是<strong>并行</strong>。每个执行器运行着完全一致的数据处理逻辑，使用着本地存储上的私有数据块。在不同的执行阶段中间有一些同步点(我的理解：了解Java Gc机制的，可以对比GC中stop-the-world,在这个同步点，所有执行器处于等待状态)，这些同步点通常被用于进行数据交换(像Spark和MapReduce中的shuffle阶段)。并行处理就能数倍提升<strong>处理速度</strong>。这里有一个经典的MPP查询时间线的例子： 每个垂直的虚线是一个同步点。例如：同步阶段要求在集群中”shuffle”数据以用于join和聚合(aggregations)操作,因此同步阶段可能执行一些数据聚合，表join，数据排序的操作，而每个执行器执行剩下的计算任务。</p>
</li>
</ul>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/b0535a047b5b6d49cb2e46d0cfc742ad.jpeg" class="" title="img">

<h4 id="MPP的设计缺陷"><a href="#MPP的设计缺陷" class="headerlink" title="MPP的设计缺陷"></a>MPP的设计缺陷</h4><p>但是，这样的设计对于所有的MPP解决方案来说都有一个主要的问题——短板效应。如果一个节点总是执行的慢于集群中其他的节点，整个集群的性能就会受限于这个故障节点的执行速度(所谓木桶的短板效应)，无论集群有多少节点，都不会有所提高。这里有一个例子展示了故障节点(下图中的Executor 7)是如何降低集群的执行速度的。</p>
<img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/b3de1a83cc126b651809af6d473ccd90.jpeg" class="" title="img">

<p>大多数情况下，除了Executor 7 其他的所有执行器都是空闲状态。这是因为他们都在等待Executor 7执行完成后才能执行同步过程，这也是我们的问题的根本。比如，当MPP系统中某个节点的RAID由于磁盘问题导致的性能很慢，或者硬件或者系统问题带来的CPU性能问题等等，都会产生这样的问题。所有的MPP系统都面临这样的问题。</p>
<h1 id="数仓架构"><a href="#数仓架构" class="headerlink" title="数仓架构"></a>数仓架构</h1><img src="/2021/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93simpleDB%E5%85%A5%E9%97%A8-2/640.png" class="" title="img">

<p>Shared Everything指单个主机独立支配CPU、内存、磁盘等硬件资源，其优势是架构简单，搭建方便。但该种架构的缺陷是数据并行处理能力较差，扩展性较低。Shared Everything的典型代表的产品为SQLserver。</p>
<p>在Shared Disk架构中，CPU和内存对于各个处理单元私有，但各节点共享磁盘系统。该种架构的典型代表为DB2 pureScale和Oracle Rac。这种共享架构具备一定的扩展能力，可通过节点的增加来提升数据并行处理能力。但当存储器接口使用饱和时，磁盘IO成为了系统资源瓶颈，节点的扩充并不能提升系统性能。</p>
<p>Shared Memory指多个节点共享内存，各CPU间通过内部通讯网络（Interconnection network）进行通讯。但与Shared Disk类似，但当节点数量过高时，内存竞争（Memory contention）将成为该系统的瓶颈，单纯地堆砌节点数量并不能提升整体数据处理性能。</p>
<p>Shared Nothing的核心思想是各个数据库单元中不存在共享资源，数据处理单元对于各节点完全私有化。早在1986年加州大学伯克利分校的论文中，Michael Stonebraker从当时的数仓原型中对比了Shared Disk，Shared Memory，Shared Nothing架构，并论证了Shared Nothing在数据并行处理中的优势。各单元通过通信协议层交互，处理后的数据会逐步向上层汇总或通过通信层流转于节点间。Teradata公司在1982年申请了YNET技术专利，为无共享的大规模数据并行处理（Massive Parallel Processing）提供了先决基础。在TD数仓架构中，各节点单元通过MPL（Message Passing Layer）的BYNET物理层实现。BYNET是一个双冗余、全双工的网络，以松耦合方式将多个数据处理节点与处理引擎（Parsing Engine）高速连接起来。G行的多元化大数据平台中的TD集群正是采取该架构设计。</p>
<h1 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h1><h2 id="扫描算子"><a href="#扫描算子" class="headerlink" title="扫描算子"></a>扫描算子</h2><h3 id="indexscan-索引扫描"><a href="#indexscan-索引扫描" class="headerlink" title="indexscan 索引扫描"></a><strong>indexscan 索引扫描</strong></h3><p>当数据表中创建了索引，并使用索引字段进行查询时，会进行索引扫描。</p>
<h3 id="tablescan-顺序表扫描"><a href="#tablescan-顺序表扫描" class="headerlink" title="tablescan 顺序表扫描"></a>tablescan 顺序表扫描</h3><p>tablescan 负责从磁盘中以连续块的形式从磁盘中读取数据页。</p>
<p>一般在SQL查询中，有几张表就要有几个 tablescan 操作。在分布式数据库中，同一张表的扫描，还会被分配到多个结点使用分布式的方式执行。</p>
<h2 id="过滤算子"><a href="#过滤算子" class="headerlink" title="过滤算子"></a>过滤算子</h2><h3 id="project-投影"><a href="#project-投影" class="headerlink" title="project 投影"></a><strong>project 投影</strong></h3><p>投影操作，是从表中根据查询字段选择相关的列。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select cc_name, cc_class</span><br><span class="line"> from call_center</span><br><span class="line"> where cc_class = &#x27;large&#x27; </span><br><span class="line"> limit 10;</span><br></pre></td></tr></table></figure>
<p>在这个查询中，tablescan 操作会将 call_center 表的数据做全字段读取，project 操作负责筛选出 cc_name, cc_class 这两个列。</p>
<h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter 过滤"></a><strong>filter 过滤</strong></h3><p>filter 会根据 where 条件中的筛选条件，筛选出符合的记录。其中过滤条件也叫谓词逻辑。</p>
<p>在两表连接时，谓词逻辑可以在 join 前执行，也可以在 join 后执行。因为 join 操作是做笛卡尔积，如果在 join 后执行谓词逻辑，将大大增加计算的基数，所以一般的数据库优化执行器都会将谓词下推，让谓词逻辑在join操作前完成。</p>
<p>上述的 project 和 filter 算子可以在数据表的列和行两个维度对数据进行限定，大大缩小处理的数据量，降低资源消耗，是SQL优化时常用的方法。</p>
<h2 id="交换算子"><a href="#交换算子" class="headerlink" title="交换算子"></a>交换算子</h2><h3 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a><strong>exchange</strong></h3><p>在分布式数据库中，tablescan 等操作是分布式进行的，而各个分支结点将结果汇总的过程就是 exchange 操作。</p>
<p>exchange 操作还可以细分为 LocalExchange 和 RemoteExchange。LocalExchange 即本地数据结果汇总，没有网络IO;而RemoteExchange是数据从不同的数据结点汇总到某一结点，需要网络传输。</p>
<h3 id="join-连接"><a href="#join-连接" class="headerlink" title="join 连接"></a><strong>join 连接</strong></h3><p>连接的本质是两个表做笛卡尔积操作。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select ctr_total_return</span><br><span class="line"> from customer_total_return_t1 ctr1</span><br><span class="line"> where ctr1.ctr_total_return &gt;</span><br><span class="line"> (select avg(ctr_total_return)</span><br><span class="line"> from customer_total_return_t2 ctr2</span><br><span class="line"> where ctr1.ctr_store_sk = ctr2.ctr_store_sk);</span><br></pre></td></tr></table></figure>
<p>在这个SQl中，先会对表 customer_total_return_t2 进行读取，并以 ctr_store_sk 为 key ，统计 avg(ctr_total_return) 然后 customer_total_return_t1 和 customer_total_return_t2 会做笛卡尔积，再进行条件过滤。</p>
<h2 id="计算算子"><a href="#计算算子" class="headerlink" title="计算算子"></a>计算算子</h2><h3 id="aggregation-聚合"><a href="#aggregation-聚合" class="headerlink" title="aggregation 聚合"></a><strong>aggregation 聚合</strong></h3><p>对数据做分组聚合，统计分析。</p>
<p>一般会先在每个结点先做一次分组统计，exchange 数据汇合之后再做一次合并统计。</p>
<p>select avg(ctr_total_return)<br>from customer_total_return_test<br>where ctr_store_sk = 10;</p>
<p>上面这个查询中只有一张表，由于是分布式执行，表虽然只扫描一次，但是会在多个数据结点进行扫描，所以 avg 函数会在每个结点先执行一次，exchange 汇总完后，会再进行一次avg操作。</p>
<h3 id="values"><a href="#values" class="headerlink" title="values"></a>values</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1 + 1, DATE &#x27;2001-08-22&#x27;, ARRAY[1, 2, 3] ;</span><br></pre></td></tr></table></figure>
<p>有时SQL中数据不是从表中查询出来的，而是给定的一个数字、字符或数组，这时 values 操作会将这些标识符转化成具体的数值。</p>
<h3 id="scalar-标量"><a href="#scalar-标量" class="headerlink" title="scalar 标量"></a><strong>scalar 标量</strong></h3><p>根据策略，给定一个结果值。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line"> case when (select count(*)</span><br><span class="line"> from store_sales</span><br><span class="line"> where ss_quantity between 81 and 100) &gt; 18213</span><br><span class="line"> then 1</span><br><span class="line"> else 2 end bucket5</span><br><span class="line">from reason</span><br><span class="line">where r_reason_sk = 1</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>如case when 中根据判断条件计算结果时会使用。</p>
<h3 id="markDistinct"><a href="#markDistinct" class="headerlink" title="markDistinct"></a><strong>markDistinct</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select avg(ss_sales_price) B1_LP, </span><br><span class="line"> count(distinct ss_list_price) B1_CNTD</span><br><span class="line"> from store_sales;</span><br></pre></td></tr></table></figure>
<p>distinct操作时，对数据的类别进行标识。</p>
<h3 id="window-窗口"><a href="#window-窗口" class="headerlink" title="window 窗口"></a>window 窗口</h3><p>窗口函数是应用于窗口和分区的函数，可分为三类：排名函数，分析函数和聚合函数。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select cs_call_center_sk,</span><br><span class="line"> sum(cs_ext_sales_price) over(partition by cs_sold_date_sk) as revenueratio</span><br><span class="line"> from catalog_sales limit 100;</span><br></pre></td></tr></table></figure>
<p>窗口函数计算时，会根据 partition by 后的字段进行分区，然后进行统计分析或排名。</p>
<h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select ss.ca_county, ss.d_year</span><br><span class="line"> from ss, sc</span><br><span class="line"> where ss.ca_county = sc.ca_county</span><br><span class="line"> order by ss.d_year;</span><br></pre></td></tr></table></figure>
<p>排序操作。</p>
<h3 id="topn"><a href="#topn" class="headerlink" title="topn"></a><strong>topn</strong></h3><p>即 limit 操作，获取限定的记录条数。</p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a><strong>output</strong></h3><p>向客户端输出结果。</p>
<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><h2 id="DbIterator-amp-Operator"><a href="#DbIterator-amp-Operator" class="headerlink" title="DbIterator&amp;Operator"></a>DbIterator&amp;Operator</h2><h3 id="DbIterator"><a href="#DbIterator" class="headerlink" title="DbIterator"></a>DbIterator</h3><p>算子的祖先类，火山执行模型，每个算子继承这个接口，对外提供tuple的获取接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DbIterator is the iterator interface that all SimpleDB operators should</span></span><br><span class="line"><span class="comment"> * implement. If the iterator is not open, none of the methods should work,</span></span><br><span class="line"><span class="comment"> * and should throw an IllegalStateException.  In addition to any</span></span><br><span class="line"><span class="comment"> * resource allocation/deallocation, an open method should call any</span></span><br><span class="line"><span class="comment"> * child iterator open methods, and in a close method, an iterator</span></span><br><span class="line"><span class="comment"> * should call its children&#x27;s close methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DbIterator</span> <span class="keyword">extends</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Opens the iterator. This must be called before any of the other methods.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> DbException when there are problems opening/accessing the database.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> DbException, TransactionAbortedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns true if the iterator has more tuples.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true f the iterator has more tuples.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalStateException If the iterator has not been opened</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the next tuple from the operator (typically implementing by reading</span></span><br><span class="line"><span class="comment">   * from a child operator or an access method).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the next tuple in the iteration.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NoSuchElementException if there are no more tuples.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalStateException If the iterator has not been opened</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Tuple <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException, NoSuchElementException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Resets the iterator to the start.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> DbException when rewind is unsupported.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalStateException If the iterator has not been opened</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the TupleDesc associated with this DbIterator. </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the TupleDesc associated with this DbIterator.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TupleDesc <span class="title">getTupleDesc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Closes the iterator. When the iterator is closed, calling next(),</span></span><br><span class="line"><span class="comment">   * hasNext(), or rewind() should fail by throwing IllegalStateException.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><p>主要是除扫描外其他算子的父类，提供设置子算子的接口。因为计算算子一般都是从子算子里获取数据，然后自己处理完后再对外进行吐数据。</p>
<p>主要逻辑就是：</p>
<ol>
<li>每次上层算子要本算子吐数据时，本算子才会从子算子里获取数据</li>
<li>子算子可能会有多个</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Abstract class for implementing operators. It handles &lt;code&gt;close&lt;/code&gt;,</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;hasNext&lt;/code&gt;. Subclasses only need to implement</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;readNext&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span> <span class="keyword">implements</span> <span class="title">DbIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.open)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Operator not yet open&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            next = fetchNext();</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tuple <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException,</span></span><br><span class="line"><span class="function">            NoSuchElementException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = fetchNext();</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Tuple result = next;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next Tuple in the iterator, or null if the iteration is</span></span><br><span class="line"><span class="comment">     * finished. Operator uses this method to implement both &lt;code&gt;next&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * and &lt;code&gt;hasNext&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the next Tuple in the iterator, or null if the iteration is</span></span><br><span class="line"><span class="comment">     *         finished.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Tuple <span class="title">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> DbException,</span></span><br><span class="line"><span class="function">            TransactionAbortedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this iterator. If overridden by a subclass, they should call</span></span><br><span class="line"><span class="comment">     * super.close() in order for Operator&#x27;s internal state to be consistent.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Ensures that a future call to next() will fail</span></span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.open = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Tuple next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> open = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> estimatedCardinality = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.open = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return the children DbIterators of this operator. If there is</span></span><br><span class="line"><span class="comment">     *         only one child, return an array of only one element. For join</span></span><br><span class="line"><span class="comment">     *         operators, the order of the children is not important. But they</span></span><br><span class="line"><span class="comment">     *         should be consistent among multiple calls.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> DbIterator[] getChildren();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the children(child) of this operator. If the operator has only one</span></span><br><span class="line"><span class="comment">     * child, children[0] should be used. If the operator is a join, children[0]</span></span><br><span class="line"><span class="comment">     * and children[1] should be used.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> children</span></span><br><span class="line"><span class="comment">     *            the DbIterators which are to be set as the children(child) of</span></span><br><span class="line"><span class="comment">     *            this operator</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(DbIterator[] children)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return the TupleDesc of the output tuples of this operator</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TupleDesc <span class="title">getTupleDesc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The estimated cardinality of this operator. </span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEstimatedCardinality</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.estimatedCardinality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> card</span></span><br><span class="line"><span class="comment">     *            The estimated cardinality of this operator.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setEstimatedCardinality</span><span class="params">(<span class="keyword">int</span> card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.estimatedCardinality = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Filter-amp-Join"><a href="#Filter-amp-Join" class="headerlink" title="Filter&amp;Join"></a>Filter&amp;Join</h2><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>条件比较判断，主要是用来比较一个字段值和一个固定值是否满足某个比较条件。支持：</p>
<ol>
<li>等于</li>
<li>大于</li>
<li>小于</li>
<li>小于或等于</li>
<li>大于或等于</li>
<li>相似</li>
<li>不等于</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Predicate compares tuples to a specified Field value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Predicate</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> field;</span><br><span class="line">    <span class="keyword">private</span> Op op;</span><br><span class="line">    <span class="keyword">private</span> Field operand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constants used for return codes in Field.compare */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Op</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        EQUALS, GREATER_THAN, LESS_THAN, LESS_THAN_OR_EQ, GREATER_THAN_OR_EQ, LIKE, NOT_EQUALS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Interface to access operations by a string containing an integer</span></span><br><span class="line"><span class="comment">         * index for command-line convenience.</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">         *            a string containing a valid integer Op index</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Op <span class="title">getOp</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getOp(Integer.parseInt(s));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Interface to access operations by integer value for command-line</span></span><br><span class="line"><span class="comment">         * convenience.</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">         *            a valid integer Op index</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Op <span class="title">getOp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> values()[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == EQUALS)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;=&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == GREATER_THAN)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == LESS_THAN)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&lt;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == LESS_THAN_OR_EQ)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&lt;=&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == GREATER_THAN_OR_EQ)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&gt;=&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == LIKE)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;like&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == NOT_EQUALS)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&lt;&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;impossible to reach here&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment">     *            field number of passed in tuples to compare against.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> op</span></span><br><span class="line"><span class="comment">     *            operation to use for comparison</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operand</span></span><br><span class="line"><span class="comment">     *            field value to compare passed in tuples to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Predicate</span><span class="params">(<span class="keyword">int</span> field, Op op, Field operand)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">this</span>.field = field;</span><br><span class="line">        <span class="keyword">this</span>.op = op;</span><br><span class="line">        <span class="keyword">this</span>.operand = operand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the field number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the operator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Op <span class="title">getOp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> op;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the operand</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Field <span class="title">getOperand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> operand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares the field number of t specified in the constructor to the</span></span><br><span class="line"><span class="comment">     * operand field specified in the constructor using the operator specific in</span></span><br><span class="line"><span class="comment">     * the constructor. The comparison can be made through Field&#x27;s compare</span></span><br><span class="line"><span class="comment">     * method.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     *            The tuple to compare against</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the comparison is true, false otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Tuple t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> t.getField(field).compare(op, operand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns something useful, like &quot;f = field_id op = op_string operand =</span></span><br><span class="line"><span class="comment">     * operand_string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;f = &quot;</span> + field + <span class="string">&quot; op = &quot;</span> + op + <span class="string">&quot; operand = &quot;</span> + operand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="JoinPredicate"><a href="#JoinPredicate" class="headerlink" title="JoinPredicate"></a>JoinPredicate</h3><p>Join操作条件比较判断，主要是用来比较俩个字段值是否满足某个比较条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JoinPredicate compares fields of two tuples using a predicate. JoinPredicate</span></span><br><span class="line"><span class="comment"> * is most likely used by the Join operator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinPredicate</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> field1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> field2;</span><br><span class="line">    <span class="keyword">private</span> Predicate.Op op;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor -- create a new predicate over two fields of two tuples.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field1</span></span><br><span class="line"><span class="comment">     *            The field index into the first tuple in the predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field2</span></span><br><span class="line"><span class="comment">     *            The field index into the second tuple in the predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> op</span></span><br><span class="line"><span class="comment">     *            The operation to apply (as defined in Predicate.Op); either</span></span><br><span class="line"><span class="comment">     *            Predicate.Op.GREATER_THAN, Predicate.Op.LESS_THAN,</span></span><br><span class="line"><span class="comment">     *            Predicate.Op.EQUAL, Predicate.Op.GREATER_THAN_OR_EQ, or</span></span><br><span class="line"><span class="comment">     *            Predicate.Op.LESS_THAN_OR_EQ</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Predicate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JoinPredicate</span><span class="params">(<span class="keyword">int</span> field1, Predicate.Op op, <span class="keyword">int</span> field2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">this</span>.field1 = field1;</span><br><span class="line">        <span class="keyword">this</span>.field2 = field2;</span><br><span class="line">        <span class="keyword">this</span>.op = op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Apply the predicate to the two specified tuples. The comparison can be</span></span><br><span class="line"><span class="comment">     * made through Field&#x27;s compare method.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the tuples satisfy the predicate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Tuple t1, Tuple t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (t1.getField(field1).compare(op, t2.getField(field2))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> field1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> field2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Predicate.<span class="function">Op <span class="title">getOperator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;JoinPredicate&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;field1=&quot;</span> + field1 +</span><br><span class="line">            <span class="string">&quot;, field2=&quot;</span> + field2 +</span><br><span class="line">            <span class="string">&quot;, op=&quot;</span> + op +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Filter算子"><a href="#Filter算子" class="headerlink" title="Filter算子"></a>Filter算子</h3><p>条件过滤算子。有两个算子：</p>
<ol>
<li>Predicate</li>
<li>子算子</li>
</ol>
<p>每次返回给上层tuple时，都会先使用Predicate判断是否符合条件，如果符合才会返回给上层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Filter is an operator that implements a relational select.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter</span> <span class="keyword">extends</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> Predicate p;</span><br><span class="line">    <span class="keyword">private</span> DbIterator child;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor accepts a predicate to apply and a child operator to read</span></span><br><span class="line"><span class="comment">     * tuples to filter from.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     *            The predicate to filter tuples with</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child</span></span><br><span class="line"><span class="comment">     *            The child operator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Filter</span><span class="params">(Predicate p, DbIterator child)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Predicate <span class="title">getPredicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TupleDesc <span class="title">getTupleDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> child.getTupleDesc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, NoSuchElementException,</span></span><br><span class="line"><span class="function">            TransactionAbortedException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">super</span>.open();</span><br><span class="line">        child.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        System.out.println(child);</span><br><span class="line">        child.close();</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.rewind();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AbstractDbIterator.readNext implementation. Iterates over tuples from the</span></span><br><span class="line"><span class="comment">     * child operator, applying the predicate to them and returning those that</span></span><br><span class="line"><span class="comment">     * pass the predicate (i.e. for which the Predicate.filter() returns true.)</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The next tuple that passes the filter, or null if there are no</span></span><br><span class="line"><span class="comment">     *         more tuples</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Predicate#filter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Tuple <span class="title">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException,</span></span><br><span class="line"><span class="function">            TransactionAbortedException, DbException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">while</span> (child.hasNext()) &#123;</span><br><span class="line">            Tuple cur = child.next();</span><br><span class="line">            <span class="keyword">if</span> (p.filter(cur)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DbIterator[] getChildren() &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DbIterator[]&#123;child&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(DbIterator[] children)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (children.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        child = children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="Join算子"><a href="#Join算子" class="headerlink" title="Join算子"></a>Join算子</h3><p>有三个成员：</p>
<ol>
<li>JointPredicate</li>
<li>左子算子</li>
<li>右子算子</li>
</ol>
<p>每次返回给上层结果时，左算子和右算子进行笛卡尔积，然后对笛卡尔积使用joinPredicate进行判断是否符合join条件，如果符合就返回给上层。</p>
<p>这里可以做的优化是，如果是等于join，可以使用hashJoin来进行优化，计算效率会有极大的提升。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Join operator implements the relational join operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> <span class="keyword">extends</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JoinPredicate joinPredicate;</span><br><span class="line">    <span class="keyword">private</span> DbIterator left;</span><br><span class="line">    <span class="keyword">private</span> DbIterator right;</span><br><span class="line">    <span class="keyword">private</span> Tuple l = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Tuple r = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Field, List&lt;Tuple&gt;&gt; leftTable;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Tuple&gt; rightIterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor. Accepts to children to join and the predicate to join them</span></span><br><span class="line"><span class="comment">     * on</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p      The predicate to use to join the children</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child1 Iterator for the left(outer) relation to join</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child2 Iterator for the right(inner) relation to join</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Join</span><span class="params">(JoinPredicate p, DbIterator child1, DbIterator child2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        joinPredicate = p;</span><br><span class="line">        left = child1;</span><br><span class="line">        right = child2;</span><br><span class="line">        leftTable = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JoinPredicate <span class="title">getJoinPredicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> joinPredicate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the field name of join field1. Should be quantified by</span></span><br><span class="line"><span class="comment">     * alias or table name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getJoinField1Name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> left.getTupleDesc().getFieldName(joinPredicate.getField1());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the field name of join field2. Should be quantified by</span></span><br><span class="line"><span class="comment">     * alias or table name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getJoinField2Name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> right.getTupleDesc().getFieldName(joinPredicate.getField2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> TupleDesc#merge(TupleDesc, TupleDesc) for possible</span></span><br><span class="line"><span class="comment">     * implementation logic.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TupleDesc <span class="title">getTupleDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> TupleDesc.merge(left.getTupleDesc(), right.getTupleDesc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reconstructTable</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (joinPredicate.getOperator().equals(Predicate.Op.EQUALS)) &#123;</span><br><span class="line">            leftTable.clear();</span><br><span class="line">            <span class="keyword">while</span> (left.hasNext()) &#123;</span><br><span class="line">                Tuple t = left.next();</span><br><span class="line">                Field key = t.getField(joinPredicate.getField1());</span><br><span class="line">                leftTable.compute(key, (k, v) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        v = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    v.add(t);</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            rightIterator = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, NoSuchElementException,</span></span><br><span class="line"><span class="function">            TransactionAbortedException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">super</span>.open();</span><br><span class="line">        left.open();</span><br><span class="line">        right.open();</span><br><span class="line">        reconstructTable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        left.close();</span><br><span class="line">        right.close();</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        left.rewind();</span><br><span class="line">        right.rewind();</span><br><span class="line">        reconstructTable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Tuple <span class="title">constructTuple</span><span class="params">(Tuple l, Tuple r)</span> </span>&#123;</span><br><span class="line">        Tuple tmp = <span class="keyword">new</span> Tuple(getTupleDesc());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.getTupleDesc().numFields(); i++) &#123;</span><br><span class="line">            tmp.setField(i, l.getField(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left.getTupleDesc().numFields(); i &lt; getTupleDesc().numFields(); i++) &#123;</span><br><span class="line">            tmp.setField(i, r.getField(i - left.getTupleDesc().numFields()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next tuple generated by the join, or null if there are no</span></span><br><span class="line"><span class="comment">     * more tuples. Logically, this is the next tuple in r1 cross r2 that</span></span><br><span class="line"><span class="comment">     * satisfies the join predicate. There are many possible implementations;</span></span><br><span class="line"><span class="comment">     * the simplest is a nested loops join.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note that the tuples returned from this particular implementation of Join</span></span><br><span class="line"><span class="comment">     * are simply the concatenation of joining tuples from the left and right</span></span><br><span class="line"><span class="comment">     * relation. Therefore, if an equality predicate is used there will be two</span></span><br><span class="line"><span class="comment">     * copies of the join attribute in the results. (Removing such duplicate</span></span><br><span class="line"><span class="comment">     * columns can be done with an additional projection operator if needed.)</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * For example, if one tuple is &#123;1,2,3&#125; and the other tuple is &#123;1,5,6&#125;,</span></span><br><span class="line"><span class="comment">     * joined on equality of the first column, then this returns &#123;1,2,3,1,5,6&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The next matching tuple.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> JoinPredicate#filter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Tuple <span class="title">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;join &quot; + l + &quot; &quot;  + r + &quot; &quot; + left + &quot; &quot; + right + &quot; &quot; + joinPredicate);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (joinPredicate.getOperator().equals(Predicate.Op.EQUALS)) &#123;</span><br><span class="line">            <span class="comment">// hash join</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; rightIterator != <span class="keyword">null</span> &amp;&amp; rightIterator.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> constructTuple(rightIterator.next(), r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (right.hasNext()) &#123;</span><br><span class="line">                r = right.next();</span><br><span class="line">                List&lt;Tuple&gt; all = leftTable.getOrDefault(r.getField(joinPredicate.getField2()), <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (all != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rightIterator = all.iterator();</span><br><span class="line">                    <span class="keyword">return</span> constructTuple(rightIterator.next(), r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// nested join</span></span><br><span class="line">            <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// has more right element, so try join it</span></span><br><span class="line">                <span class="keyword">if</span> (right.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (right.hasNext()) &#123;</span><br><span class="line">                        Tuple r = right.next();</span><br><span class="line">                        <span class="keyword">if</span> (joinPredicate.filter(l, r)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> constructTuple(l, r);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// can not found one</span></span><br><span class="line">            <span class="keyword">while</span> (left.hasNext()) &#123;</span><br><span class="line">                l = left.next();</span><br><span class="line">                right.rewind();</span><br><span class="line">                <span class="keyword">while</span> (right.hasNext()) &#123;</span><br><span class="line">                    Tuple r = right.next();</span><br><span class="line">                    <span class="keyword">if</span> (joinPredicate.filter(l, r)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> constructTuple(l, r);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DbIterator[] getChildren() &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DbIterator[]&#123;left, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(DbIterator[] children)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (children.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left = children[<span class="number">0</span>];</span><br><span class="line">        right = children[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h2><h3 id="IntegerAggregator-amp-StringAggregator-amp-Aggregate"><a href="#IntegerAggregator-amp-StringAggregator-amp-Aggregate" class="headerlink" title="IntegerAggregator&amp;StringAggregator&amp;Aggregate"></a>IntegerAggregator&amp;StringAggregator&amp;Aggregate</h3><h4 id="IntegerAggregator"><a href="#IntegerAggregator" class="headerlink" title="IntegerAggregator"></a>IntegerAggregator</h4><p>支持对整型的字段进行聚合求值。另外，也支持对整型的指定字段进行分组后聚合求值。</p>
<p>有四个重要成员：</p>
<ol>
<li>要分组字段的编号</li>
<li>要分组字段的值类型</li>
<li>要进行聚合计算的字段的编号</li>
<li>聚合函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Knows how to compute some aggregate over a set of IntFields.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerAggregator</span> <span class="keyword">implements</span> <span class="title">Aggregator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gbfield;</span><br><span class="line">    <span class="keyword">private</span> Type gbType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> afield;</span><br><span class="line">    <span class="keyword">private</span> Op what;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Field, AggValue&gt; groupByField;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Aggregate constructor</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gbfield</span></span><br><span class="line"><span class="comment">     *            the 0-based index of the group-by field in the tuple, or</span></span><br><span class="line"><span class="comment">     *            NO_GROUPING if there is no grouping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gbfieldtype</span></span><br><span class="line"><span class="comment">     *            the type of the group by field (e.g., Type.INT_TYPE), or null</span></span><br><span class="line"><span class="comment">     *            if there is no grouping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> afield</span></span><br><span class="line"><span class="comment">     *            the 0-based index of the aggregate field in the tuple</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> what</span></span><br><span class="line"><span class="comment">     *            the aggregation operator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntegerAggregator</span><span class="params">(<span class="keyword">int</span> gbfield, Type gbfieldtype, <span class="keyword">int</span> afield, Op what)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">this</span>.gbfield = gbfield;</span><br><span class="line">        <span class="keyword">this</span>.gbType = gbfieldtype;</span><br><span class="line">        <span class="keyword">this</span>.afield = afield;</span><br><span class="line">        <span class="keyword">this</span>.what = what;</span><br><span class="line">        <span class="keyword">this</span>.groupByField = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merge a new tuple into the aggregate, grouping as indicated in the</span></span><br><span class="line"><span class="comment">     * constructor</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tup</span></span><br><span class="line"><span class="comment">     *            the Tuple containing an aggregate field and a group-by field</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeTupleIntoGroup</span><span class="params">(Tuple tup)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        AggValue agg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (gbfield == -<span class="number">1</span>) &#123;</span><br><span class="line">            groupByField.putIfAbsent(<span class="keyword">new</span> IntField(NO_GROUPING), <span class="keyword">new</span> AggValue());</span><br><span class="line">            agg = groupByField.get(<span class="keyword">new</span> IntField(NO_GROUPING));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupByField.putIfAbsent(tup.getField(gbfield), <span class="keyword">new</span> AggValue());</span><br><span class="line">            agg = groupByField.get(tup.getField(gbfield));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        agg.count++;</span><br><span class="line">        <span class="keyword">int</span> cur = ((IntField) tup.getField(afield)).getValue();</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> AVG:</span><br><span class="line">            <span class="keyword">case</span> SUM:</span><br><span class="line">                agg.sum += cur;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAX:</span><br><span class="line">                <span class="keyword">if</span> (agg.max &lt; cur) &#123;</span><br><span class="line">                    agg.max = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MIN:</span><br><span class="line">                <span class="keyword">if</span> (agg.min &gt; cur) &#123;</span><br><span class="line">                    agg.min = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> COUNT:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AggValue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAvg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sum/count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a DbIterator over group aggregate results.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a DbIterator whose tuples are the pair (groupVal, aggregateVal)</span></span><br><span class="line"><span class="comment">     *         if using group, or a single (aggregateVal) if no grouping. The</span></span><br><span class="line"><span class="comment">     *         aggregateVal is determined by the type of aggregate specified in</span></span><br><span class="line"><span class="comment">     *         the constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DbIterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntAggIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IntAggIterator</span> <span class="keyword">implements</span> <span class="title">DbIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Field, AggValue&gt;&gt; iterator = <span class="keyword">null</span>;</span><br><span class="line">        TupleDesc tupleDesc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">            iterator = groupByField.entrySet().iterator();</span><br><span class="line">            <span class="keyword">if</span> (gbfield == Aggregator.NO_GROUPING) &#123;</span><br><span class="line">                Type[] type = <span class="keyword">new</span> Type[]&#123;Type.INT_TYPE&#125;;</span><br><span class="line">                tupleDesc = <span class="keyword">new</span> TupleDesc(type);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Type[] types = <span class="keyword">new</span> Type[]&#123;gbType, Type.INT_TYPE&#125;;</span><br><span class="line">                tupleDesc = <span class="keyword">new</span> TupleDesc(types);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> iterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException, NoSuchElementException </span>&#123;</span><br><span class="line">            Map.Entry&lt;Field, AggValue&gt; entry = iterator.next();</span><br><span class="line">            Tuple tuple = <span class="keyword">new</span> Tuple(tupleDesc);</span><br><span class="line">            <span class="keyword">if</span> (tupleDesc.numFields() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                tuple.setField(<span class="number">0</span>, entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">                <span class="keyword">case</span> AVG:</span><br><span class="line">                    <span class="keyword">if</span> (tupleDesc.numFields() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        tuple.setField(<span class="number">1</span>, <span class="keyword">new</span> IntField(entry.getValue().getAvg()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tuple.setField(<span class="number">0</span>, <span class="keyword">new</span> IntField(entry.getValue().getAvg()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SUM:</span><br><span class="line">                    <span class="keyword">if</span> (tupleDesc.numFields() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        tuple.setField(<span class="number">1</span>, <span class="keyword">new</span> IntField(entry.getValue().getSum()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tuple.setField(<span class="number">0</span>, <span class="keyword">new</span> IntField(entry.getValue().getSum()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MAX:</span><br><span class="line">                    <span class="keyword">if</span> (tupleDesc.numFields() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        tuple.setField(<span class="number">1</span>, <span class="keyword">new</span> IntField(entry.getValue().getMax()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tuple.setField(<span class="number">0</span>, <span class="keyword">new</span> IntField(entry.getValue().getMax()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MIN:</span><br><span class="line">                    <span class="keyword">if</span> (tupleDesc.numFields() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        tuple.setField(<span class="number">1</span>, <span class="keyword">new</span> IntField(entry.getValue().getMin()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tuple.setField(<span class="number">0</span>, <span class="keyword">new</span> IntField(entry.getValue().getMin()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> COUNT:</span><br><span class="line">                    <span class="keyword">if</span> (tupleDesc.numFields() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        tuple.setField(<span class="number">1</span>, <span class="keyword">new</span> IntField(entry.getValue().getCount()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tuple.setField(<span class="number">0</span>, <span class="keyword">new</span> IntField(entry.getValue().getCount()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> tuple;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">            iterator = groupByField.entrySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TupleDesc <span class="title">getTupleDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tupleDesc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            tupleDesc = <span class="keyword">null</span>;</span><br><span class="line">            iterator = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StringAggregator"><a href="#StringAggregator" class="headerlink" title="StringAggregator"></a>StringAggregator</h4><p>同IntegerAggregator，但是聚合函数只支持count。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Knows how to compute some aggregate over a set of StringFields.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringAggregator</span> <span class="keyword">implements</span> <span class="title">Aggregator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gbfield;</span><br><span class="line">    <span class="keyword">private</span> Type gbType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> afield;</span><br><span class="line">    <span class="keyword">private</span> Op what;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Field, Integer&gt; groupByField;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Aggregate constructor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gbfield the 0-based index of the group-by field in the tuple, or NO_GROUPING if there is no grouping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gbfieldtype the type of the group by field (e.g., Type.INT_TYPE), or null if there is no grouping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> afield the 0-based index of the aggregate field in the tuple</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> what aggregation operator to use -- only supports COUNT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if what != COUNT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringAggregator</span><span class="params">(<span class="keyword">int</span> gbfield, Type gbfieldtype, <span class="keyword">int</span> afield, Op what)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (!what.equals(Op.COUNT)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;string can not support aggerator &quot;</span> + what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.gbfield = gbfield;</span><br><span class="line">        <span class="keyword">this</span>.gbType = gbfieldtype;</span><br><span class="line">        <span class="keyword">this</span>.afield = afield;</span><br><span class="line">        <span class="keyword">this</span>.what = what;</span><br><span class="line">        groupByField = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merge a new tuple into the aggregate, grouping as indicated in the constructor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tup the Tuple containing an aggregate field and a group-by field</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeTupleIntoGroup</span><span class="params">(Tuple tup)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (gbfield == -<span class="number">1</span>) &#123;</span><br><span class="line">            groupByField.compute(<span class="keyword">new</span> IntField(NO_GROUPING), (k, v) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    v = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    v += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupByField.compute(tup.getField(gbfield), (k, v) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    v = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    v += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a DbIterator over group aggregate results.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a DbIterator whose tuples are the pair (groupVal,</span></span><br><span class="line"><span class="comment">     *   aggregateVal) if using group, or a single (aggregateVal) if no</span></span><br><span class="line"><span class="comment">     *   grouping. The aggregateVal is determined by the type of</span></span><br><span class="line"><span class="comment">     *   aggregate specified in the constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DbIterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringAggIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StringAggIterator</span> <span class="keyword">implements</span> <span class="title">DbIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Field, Integer&gt;&gt; iterator = <span class="keyword">null</span>;</span><br><span class="line">        TupleDesc tupleDesc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">            iterator = groupByField.entrySet().iterator();</span><br><span class="line">            <span class="keyword">if</span> (gbfield == Aggregator.NO_GROUPING) &#123;</span><br><span class="line">                Type[] type = <span class="keyword">new</span> Type[]&#123;Type.INT_TYPE&#125;;</span><br><span class="line">                tupleDesc = <span class="keyword">new</span> TupleDesc(type);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Type[] types = <span class="keyword">new</span> Type[]&#123;gbType, Type.INT_TYPE&#125;;</span><br><span class="line">                tupleDesc = <span class="keyword">new</span> TupleDesc(types);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> iterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException, NoSuchElementException </span>&#123;</span><br><span class="line">            Map.Entry&lt;Field, Integer&gt; entry = iterator.next();</span><br><span class="line">            Tuple tuple = <span class="keyword">new</span> Tuple(tupleDesc);</span><br><span class="line">            <span class="keyword">if</span> (tupleDesc.numFields() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                tuple.setField(<span class="number">0</span>, entry.getKey());</span><br><span class="line">                tuple.setField(<span class="number">1</span>, <span class="keyword">new</span> IntField(entry.getValue()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tuple.setField(<span class="number">0</span>, <span class="keyword">new</span> IntField(entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> tuple;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">            iterator = groupByField.entrySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TupleDesc <span class="title">getTupleDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tupleDesc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            tupleDesc = <span class="keyword">null</span>;</span><br><span class="line">            iterator = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h4><p>对外提供聚合算子，有五个重要的成员：</p>
<ol>
<li>子算子</li>
<li>子算子的聚合的字段编号</li>
<li>子算子要做分组的字段编号</li>
<li>聚合函数</li>
<li>实际的聚合器（即上面的两种，分别针对不同数据类型字段的聚合器，会根据上面四个成员来构建）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Aggregation operator that computes an aggregate (e.g., sum, avg, max,</span></span><br><span class="line"><span class="comment"> * min). Note that we only support aggregates over a single column, grouped by a</span></span><br><span class="line"><span class="comment"> * single column.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aggregate</span> <span class="keyword">extends</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DbIterator child;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> afield;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gfield;</span><br><span class="line">    <span class="keyword">private</span> Aggregator.Op aop;</span><br><span class="line">    <span class="keyword">private</span> Aggregator aggregator;</span><br><span class="line">    <span class="keyword">private</span> DbIterator ret;</span><br><span class="line">    <span class="keyword">private</span> TupleDesc tupleDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Implementation hint: depending on the type of afield, you will want to</span></span><br><span class="line"><span class="comment">     * construct an &#123;<span class="doctag">@link</span> IntAggregator&#125; or &#123;<span class="doctag">@link</span> StringAggregator&#125; to help</span></span><br><span class="line"><span class="comment">     * you with your implementation of readNext().</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child</span></span><br><span class="line"><span class="comment">     *            The DbIterator that is feeding us tuples.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> afield</span></span><br><span class="line"><span class="comment">     *            The column over which we are computing an aggregate.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gfield</span></span><br><span class="line"><span class="comment">     *            The column over which we are grouping the result, or -1 if</span></span><br><span class="line"><span class="comment">     *            there is no grouping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aop</span></span><br><span class="line"><span class="comment">     *            The aggregation operator to use</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Aggregate</span><span class="params">(DbIterator child, <span class="keyword">int</span> afield, <span class="keyword">int</span> gfield, Aggregator.Op aop)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">        <span class="keyword">this</span>.afield = afield;</span><br><span class="line">        <span class="keyword">this</span>.gfield = gfield;</span><br><span class="line">        <span class="keyword">this</span>.aop = aop;</span><br><span class="line"></span><br><span class="line">        TupleDesc td = child.getTupleDesc();</span><br><span class="line">        <span class="keyword">if</span> (td.getFieldType(afield) == Type.INT_TYPE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gfield == Aggregator.NO_GROUPING) &#123;</span><br><span class="line">                aggregator = <span class="keyword">new</span> IntegerAggregator(gfield, <span class="keyword">null</span>, afield, aop);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                aggregator = <span class="keyword">new</span> IntegerAggregator(gfield, td.getFieldType(gfield), afield, aop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (gfield == Aggregator.NO_GROUPING) &#123;</span><br><span class="line">                aggregator = <span class="keyword">new</span> StringAggregator(gfield, <span class="keyword">null</span>, afield, aop);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                aggregator = <span class="keyword">new</span> StringAggregator(gfield, td.getFieldType(gfield), afield, aop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gfield == Aggregator.NO_GROUPING) &#123;</span><br><span class="line">            tupleDesc = <span class="keyword">new</span> TupleDesc(<span class="keyword">new</span> Type[]&#123;Type.INT_TYPE&#125;, <span class="keyword">new</span> String[]&#123;td.getFieldName(afield)&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tupleDesc = <span class="keyword">new</span> TupleDesc(<span class="keyword">new</span> Type[]&#123;td.getFieldType(gfield), Type.INT_TYPE&#125;, <span class="keyword">new</span> String[]&#123;td.getFieldName(gfield), td.getFieldName(afield)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> If this aggregate is accompanied by a groupby, return the groupby</span></span><br><span class="line"><span class="comment">     *         field index in the &lt;b&gt;INPUT&lt;/b&gt; tuples. If not, return</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@link</span> Aggregator#NO_GROUPING&#125;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">groupField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// some code goes here</span></span><br><span class="line">	    <span class="keyword">return</span> gfield;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> If this aggregate is accompanied by a group by, return the name</span></span><br><span class="line"><span class="comment">     *         of the groupby field in the &lt;b&gt;OUTPUT&lt;/b&gt; tuples If not, return</span></span><br><span class="line"><span class="comment">     *         null;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">groupFieldName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (gfield == Aggregator.NO_GROUPING) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="keyword">return</span> child.getTupleDesc().getFieldName(gfield);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the aggregate field</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">aggregateField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// some code goes here</span></span><br><span class="line">	    <span class="keyword">return</span> afield;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return the name of the aggregate field in the &lt;b&gt;OUTPUT&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     *         tuples</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">aggregateFieldName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// some code goes here</span></span><br><span class="line">	    <span class="keyword">return</span> child.getTupleDesc().getFieldName(afield);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return the aggregate operator</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> Aggregator.<span class="function">Op <span class="title">aggregateOp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// some code goes here</span></span><br><span class="line">	    <span class="keyword">return</span> aop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">nameOfAggregatorOp</span><span class="params">(Aggregator.Op aop)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> aop.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException, DbException,</span></span><br><span class="line"><span class="function">	    TransactionAbortedException </span>&#123;</span><br><span class="line">	    <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">super</span>.open();</span><br><span class="line">        child.open();</span><br><span class="line">        <span class="keyword">while</span> (child.hasNext()) &#123;</span><br><span class="line">            aggregator.mergeTupleIntoGroup(child.next());</span><br><span class="line">        &#125;</span><br><span class="line">        ret = aggregator.iterator();</span><br><span class="line">        ret.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next tuple. If there is a group by field, then the first</span></span><br><span class="line"><span class="comment">     * field is the field by which we are grouping, and the second field is the</span></span><br><span class="line"><span class="comment">     * result of computing the aggregate, If there is no group by field, then</span></span><br><span class="line"><span class="comment">     * the result tuple should contain one field representing the result of the</span></span><br><span class="line"><span class="comment">     * aggregate. Should return null if there are no more tuples.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Tuple <span class="title">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException </span>&#123;</span><br><span class="line">	<span class="comment">// some code goes here</span></span><br><span class="line">	    <span class="keyword">if</span> (ret.hasNext()) &#123;</span><br><span class="line">	        <span class="keyword">return</span> ret.next();</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">	<span class="comment">// some code goes here</span></span><br><span class="line">        child.rewind();</span><br><span class="line">        ret.rewind();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the TupleDesc of this Aggregate. If there is no group by field,</span></span><br><span class="line"><span class="comment">     * this will have one field - the aggregate column. If there is a group by</span></span><br><span class="line"><span class="comment">     * field, the first field will be the group by field, and the second will be</span></span><br><span class="line"><span class="comment">     * the aggregate value column.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * The name of an aggregate column should be informative. For example:</span></span><br><span class="line"><span class="comment">     * &quot;aggName(aop) (child_td.getFieldName(afield))&quot; where aop and afield are</span></span><br><span class="line"><span class="comment">     * given in the constructor, and child_td is the TupleDesc of the child</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TupleDesc <span class="title">getTupleDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// some code goes here</span></span><br><span class="line">	<span class="keyword">return</span> tupleDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">        child.close();</span><br><span class="line">        ret.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DbIterator[] getChildren() &#123;</span><br><span class="line">	<span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DbIterator[]&#123;child&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(DbIterator[] children)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// some code goes here</span></span><br><span class="line">        child = children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Insert-amp-Delete"><a href="#Insert-amp-Delete" class="headerlink" title="Insert&amp;Delete"></a>Insert&amp;Delete</h2><p>这两个算子其实需要依赖于heapFile对应的Insert和Delete接口。而HeapFile的接口依赖于BufferPoolManager的insertTuple和DeleteTuple接口，而BufferPoolManager则是依赖于HeapPage的InsertTuple和DeleteTuple接口。那既然数据都到HeapPage了，HeapPage怎么落盘的呢，通过HeapFile的WritePage接口。</p>
<p>因此：</p>
<ol>
<li>数据在内存和磁盘中流转是通过整Page</li>
<li>数据写入和删除是通过Tuple，只是在内存中操作。</li>
</ol>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>插入算子，有三个重要成员：</p>
<ol>
<li>事务Id</li>
<li>子算子</li>
<li>表Id</li>
</ol>
<p>实现的功能是从子算子里取出数据，然后插入到指定的table里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts tuples read from the child operator into the tableid specified in the</span></span><br><span class="line"><span class="comment"> * constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insert</span> <span class="keyword">extends</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> TransactionId tid;</span><br><span class="line">    <span class="keyword">private</span> DbIterator child;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tableId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasReturn = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     *            The transaction running the insert.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child</span></span><br><span class="line"><span class="comment">     *            The child operator from which to read tuples to be inserted.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableid</span></span><br><span class="line"><span class="comment">     *            The table in which to insert tuples.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> DbException</span></span><br><span class="line"><span class="comment">     *             if TupleDesc of child differs from table into which we are to</span></span><br><span class="line"><span class="comment">     *             insert.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Insert</span><span class="params">(TransactionId t,DbIterator child, <span class="keyword">int</span> tableid)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> DbException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">this</span>.tid = t;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">        <span class="keyword">this</span>.tableId = tableid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TupleDesc <span class="title">getTupleDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TupleDesc(<span class="keyword">new</span> Type[]&#123;Type.INT_TYPE&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">super</span>.open();</span><br><span class="line">        child.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.close();</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.rewind();</span><br><span class="line">        hasReturn = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts tuples read from child into the tableid specified by the</span></span><br><span class="line"><span class="comment">     * constructor. It returns a one field tuple containing the number of</span></span><br><span class="line"><span class="comment">     * inserted records. Inserts should be passed through BufferPool. An</span></span><br><span class="line"><span class="comment">     * instances of BufferPool is available via Database.getBufferPool(). Note</span></span><br><span class="line"><span class="comment">     * that insert DOES NOT need check to see if a particular tuple is a</span></span><br><span class="line"><span class="comment">     * duplicate before inserting it.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A 1-field tuple containing the number of inserted records, or</span></span><br><span class="line"><span class="comment">     *         null if called more than once.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Database#getBufferPool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BufferPool#insertTuple</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Tuple <span class="title">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (hasReturn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (child.hasNext()) &#123;</span><br><span class="line">            Tuple t = child.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Database.getCatalog().getDbFile(tableId).insertTuple(tid, t);</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Tuple ret = <span class="keyword">new</span> Tuple(<span class="keyword">new</span> TupleDesc(<span class="keyword">new</span> Type[]&#123;Type.INT_TYPE&#125;));</span><br><span class="line">        ret.setField(<span class="number">0</span>, <span class="keyword">new</span> IntField(count));</span><br><span class="line">        hasReturn = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DbIterator[] getChildren() &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DbIterator[]&#123;child&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(DbIterator[] children)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (children.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        child = children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>删除算子，有三个重要成员：</p>
<ol>
<li>事务Id</li>
<li>子算子</li>
<li>表Id</li>
</ol>
<p>实现的功能是从子算子里取出数据，然后从指定的table里删除这些tuple。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The delete operator. Delete reads tuples from its child operator and removes</span></span><br><span class="line"><span class="comment"> * them from the table they belong to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Delete</span> <span class="keyword">extends</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> TransactionId tid;</span><br><span class="line">    <span class="keyword">private</span> DbIterator child;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasReturn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor specifying the transaction that this delete belongs to as</span></span><br><span class="line"><span class="comment">     * well as the child to read from.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     *            The transaction this delete runs in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child</span></span><br><span class="line"><span class="comment">     *            The child operator from which to read tuples for deletion</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Delete</span><span class="params">(TransactionId t, DbIterator child)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">this</span>.tid = t;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TupleDesc <span class="title">getTupleDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> child.getTupleDesc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">super</span>.open();</span><br><span class="line">        child.open();</span><br><span class="line">        hasReturn = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.close();</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.rewind();</span><br><span class="line">        hasReturn = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deletes tuples as they are read from the child operator. Deletes are</span></span><br><span class="line"><span class="comment">     * processed via the buffer pool (which can be accessed via the</span></span><br><span class="line"><span class="comment">     * Database.getBufferPool() method.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A 1-field tuple containing the number of deleted records.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Database#getBufferPool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BufferPool#deleteTuple</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Tuple <span class="title">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (hasReturn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (child.hasNext()) &#123;</span><br><span class="line">            Tuple t = child.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Database.getCatalog().getDbFile(t.getRecordId().getPageId().getTableId()).deleteTuple(tid, t);</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (DbException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Tuple ret = <span class="keyword">new</span> Tuple(<span class="keyword">new</span> TupleDesc(<span class="keyword">new</span> Type[]&#123;Type.INT_TYPE&#125;, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;count&quot;</span>&#125;));</span><br><span class="line">        ret.setField(<span class="number">0</span>, <span class="keyword">new</span> IntField(count));</span><br><span class="line">        hasReturn = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DbIterator[] getChildren() &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DbIterator[]&#123;child&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(DbIterator[] children)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (children.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        child = children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Page置换"><a href="#Page置换" class="headerlink" title="Page置换"></a>Page置换</h2><p>BufferPoolManager是一个缓存池，因此肯定需要有换入和缓存的策略来保证系统正常work。一般采用LRU算法，经典的LRU算法就是采用一个链表实现。使用频繁的总是放在链表头，替换时总是替换末尾的元素。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整体来说算子这块本次作业开始涉及到数据库的核心技术了，做了以下几个设计：</p>
<ol>
<li>计算引擎采用火山模型，算子之间数据流转单位都是一个Tuple</li>
<li>定义了算子的统一接口：open、close、hasNext、next、rewind</li>
<li>每个计算算子都有一到多个子算子，还有一个处理函数。大概的处理逻辑就是不停从子算子获取数据，然后加上自己的处理函数进行计算，满足一些判断条件后才会返回给上层</li>
<li>普通过滤算子，例如filter和join会带有判断条件</li>
<li>聚合计算算子，会含有指定类型的聚合器（例如整型和string类型的聚合器），并且支持分组操作，会根据给定的条件和字段类型，选择指定类型的聚合器进行聚合计算</li>
</ol>
<p>整体来看，其实代码框架搭建的非常清晰</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/100933389">数据库计算引擎的优化技术：向量化执行与代码生成</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/347590633">分布式计算（1）：分布式计算模式之MR</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cxybb.com/article/qq_38704184/84402387">MR计算模型一_小东升职记-程序员宝宝_mr模型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yijiyong.com/dp/tez/03-summary.html">Tez-精华知识总结</a></li>
<li><a target="_blank" rel="noopener" href="https://web.eecs.umich.edu/~mosharaf/Readings/Tez.pdf">Apache Tez: A Unifying Framework for Modeling and Building Data Processing Applications</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jifengblog/p/9369233.html">Spark计算模型RDD</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/oPpQzsJIFopeBpzVcbx7">深入浅出 Spark（一）：内存计算的由来</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq1010885678/article/details/45788083">Spark（六） – Spark计算模型</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/165158261">DAGScheduler概述</a></li>
<li><a target="_blank" rel="noopener" href="https://toutiao.io/posts/2a9ayg/preview">MPP 的进化：深入理解 Batch 和 MPP 优缺点</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/835349">MPP大规模并行处理架构详解</a></li>
<li><a target="_blank" rel="noopener" href="https://toutiao.io/posts/90l4u1u/preview">浅谈数仓Shared Nothing架构</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/349450583">「分布式技术专题」常用的SQL算子介绍</a></li>
</ol>
<!-- flag of hidden posts -->
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/database/" rel="tag"># database</a>
              <a href="/tags/simpleDB/" rel="tag"># simpleDB</a>
          </div>

        

    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason Chao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
